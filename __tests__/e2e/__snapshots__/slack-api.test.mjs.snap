// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`E2E: Slack API Tests should generate Slack API files with infinite query support: slack-api-generated-files 1`] = `
Object {
  "config.ts": "/**
 * You can modify this file
 *
 * @version 6
 */
import Axios, {
  AxiosRequestConfig,
  AxiosError,
  AxiosResponse,
  AxiosInstance,
} from \\"axios\\";
//@ts-ignore
import qs from \\"qs\\";

const baseConfig: AxiosRequestConfig = {
  baseURL: \\"https://slack.com/api\\", // <--- Add your base url
  headers: {
    \\"Content-Encoding\\": \\"UTF-8\\",
    Accept: \\"application/json\\",
    \\"Content-Type\\": \\"application/json-patch+json\\",
  },
  paramsSerializer: (param) => qs.stringify(param, { indices: false }),
};

let axiosInstance: AxiosInstance;

function getAxiosInstance(security: Security): AxiosInstance {
  if (!axiosInstance) {
    axiosInstance = Axios.create(baseConfig);

    // Response interceptor
    axiosInstance.interceptors.response.use(
      (async (response: AxiosResponse): Promise<SwaggerResponse<any>> => {
        // Any status code that lie within the range of 2xx cause this function to trigger
        // Do something with response data
        /**
         * Example on response manipulation
         *
         * @example
         *   const swaggerResponse: SwaggerResponse = {
         *     ...response,
         *   };
         *   return swaggerResponse;
         */
        return response.data;
      }) as any,
      (error: AxiosError) => {
        // Any status codes that falls outside the range of 2xx cause this function to trigger
        // Do something with response error

        if (error.response) {
          return Promise.reject(
            new RequestError(
              error.response.data,
              error.response.status,
              error.response,
            ),
          );
        }

        if (error.isAxiosError) {
          return Promise.reject(new RequestError(\\"noInternetConnection\\"));
        }
        return Promise.reject(error);
      },
    );
  }

  // ًًRequest interceptor
  axiosInstance.interceptors.request.use(
    async (requestConfig) => {
      // Do something before request is sent
      /** Example on how to add authorization based on security */
      if (security?.[0]) {
        // requestConfig.headers.authorization = \\"\\";
      }

      return requestConfig;
    },
    (error) => {
      // Do something with request error
      return Promise.reject(error);
    },
  );

  return axiosInstance;
}

class RequestError extends Error {
  constructor(
    public message: string,
    public status?: number,
    public response?: AxiosResponse,
  ) {
    super(message);
  }

  isApiException = true;

  static isRequestError(error: any): error is RequestError {
    return error.isApiException;
  }
}

export type Security = any[] | undefined;

// export interface SwaggerResponse<R> extends AxiosResponse<R> {}
export type SwaggerResponse<R> = R;

export { getAxiosInstance, RequestError };
",
  "hooks.ts": "//@ts-nocheck
/**
 * AUTO_GENERATED Do not change this file directly, use config.ts file instead
 *
 * @version 6
 */

import { useMemo } from \\"react\\";
import { AxiosRequestConfig } from \\"axios\\";
import {
  UseQueryOptions,
  useQuery,
  useMutation,
  UseMutationOptions,
  useInfiniteQuery,
  UseInfiniteQueryOptions,
  QueryClient,
  QueryKey,
} from \\"@tanstack/react-query\\";
import { RequestError, SwaggerResponse } from \\"./config\\";
import { paginationFlattenData, getPageSize, getTotal } from \\"./hooksConfig\\";
import type {
  GetAdminAppsApprovedListQueryParams,
  GetAdminAppsRequestsListQueryParams,
  GetAdminAppsRestrictedListQueryParams,
  GetAdminConversationsEkmListOriginalConnectedChannelInfoQueryParams,
  GetAdminConversationsGetConversationPrefsQueryParams,
  GetAdminConversationsGetTeamsQueryParams,
  GetAdminConversationsRestrictAccessListGroupsQueryParams,
  GetAdminConversationsSearchQueryParams,
  GetAdminEmojiListQueryParams,
  GetAdminInviteRequestsApprovedListQueryParams,
  GetAdminInviteRequestsDeniedListQueryParams,
  GetAdminInviteRequestsListQueryParams,
  GetAdminTeamsAdminsListQueryParams,
  GetAdminTeamsListQueryParams,
  GetAdminTeamsOwnersListQueryParams,
  GetAdminTeamsSettingsInfoQueryParams,
  GetAdminUsergroupsListChannelsQueryParams,
  GetAdminUsersListQueryParams,
  GetApiTestQueryParams,
  GetAppsEventAuthorizationsListQueryParams,
  GetAppsPermissionsInfoQueryParams,
  GetAppsPermissionsRequestQueryParams,
  GetAppsPermissionsResourcesListQueryParams,
  GetAppsPermissionsScopesListQueryParams,
  GetAppsPermissionsUsersListQueryParams,
  GetAppsPermissionsUsersRequestQueryParams,
  GetAppsUninstallQueryParams,
  GetAuthRevokeQueryParams,
  GetBotsInfoQueryParams,
  GetCallsInfoQueryParams,
  GetChatGetPermalinkQueryParams,
  GetChatScheduledMessagesListQueryParams,
  GetConversationsHistoryQueryParams,
  GetConversationsInfoQueryParams,
  GetConversationsListQueryParams,
  GetConversationsMembersQueryParams,
  GetConversationsRepliesQueryParams,
  GetDialogOpenQueryParams,
  GetDndInfoQueryParams,
  GetDndTeamInfoQueryParams,
  GetEmojiListQueryParams,
  GetFilesInfoQueryParams,
  GetFilesListQueryParams,
  GetFilesRemoteInfoQueryParams,
  GetFilesRemoteListQueryParams,
  GetFilesRemoteShareQueryParams,
  GetMigrationExchangeQueryParams,
  GetOauthAccessQueryParams,
  GetOauthTokenQueryParams,
  GetOauthV2AccessQueryParams,
  GetPinsListQueryParams,
  GetReactionsGetQueryParams,
  GetReactionsListQueryParams,
  GetRemindersInfoQueryParams,
  GetRemindersListQueryParams,
  GetRtmConnectQueryParams,
  GetSearchMessagesQueryParams,
  GetStarsListQueryParams,
  GetTeamAccessLogsQueryParams,
  GetTeamBillableInfoQueryParams,
  GetTeamInfoQueryParams,
  GetTeamIntegrationLogsQueryParams,
  GetTeamProfileGetQueryParams,
  GetUsergroupsListQueryParams,
  GetUsergroupsUsersListQueryParams,
  GetUsersConversationsQueryParams,
  GetUsersGetPresenceQueryParams,
  GetUsersIdentityQueryParams,
  GetUsersInfoQueryParams,
  GetUsersListQueryParams,
  GetUsersLookupByEmailQueryParams,
  GetUsersProfileGetQueryParams,
  GetViewsOpenQueryParams,
  GetViewsPublishQueryParams,
  GetViewsPushQueryParams,
  GetViewsUpdateQueryParams,
  GetWorkflowsStepCompletedQueryParams,
  GetWorkflowsStepFailedQueryParams,
  GetWorkflowsUpdateStepQueryParams,
  Defs_app_id,
  Defs_bot_id,
  Defs_channel,
  Defs_channel_id,
  Defs_dm_id,
  Defs_group_id,
  Defs_ok_true,
  Defs_team,
  Defs_ts,
  Defs_user_id,
  Objs_bot_profile,
  Objs_channel,
  Objs_comment,
  Objs_comments,
  Objs_conversation,
  Objs_file,
  Objs_message,
  Objs_paging,
  Objs_reminder,
  Objs_resources,
  Objs_response_metadata,
  Objs_scopes,
  Objs_subteam,
  Objs_team,
  Objs_team_profile_field,
  Objs_user,
  Objs_user_profile,
  Objs_user_profile_short,
} from \\"./types\\";
import {
  getAdminAppsApprovedList,
  getAdminAppsRequestsList,
  getAdminAppsRestrictedList,
  getAdminConversationsEkmListOriginalConnectedChannelInfo,
  getAdminConversationsGetConversationPrefs,
  getAdminConversationsGetTeams,
  getAdminConversationsRestrictAccessListGroups,
  getAdminConversationsSearch,
  getAdminEmojiList,
  getAdminInviteRequestsApprovedList,
  getAdminInviteRequestsDeniedList,
  getAdminInviteRequestsList,
  getAdminTeamsAdminsList,
  getAdminTeamsList,
  getAdminTeamsOwnersList,
  getAdminTeamsSettingsInfo,
  getAdminUsergroupsListChannels,
  getAdminUsersList,
  getApiTest,
  getAppsEventAuthorizationsList,
  getAppsPermissionsInfo,
  getAppsPermissionsRequest,
  getAppsPermissionsResourcesList,
  getAppsPermissionsScopesList,
  getAppsPermissionsUsersList,
  getAppsPermissionsUsersRequest,
  getAppsUninstall,
  getAuthRevoke,
  getAuthTest,
  getBotsInfo,
  getCallsInfo,
  getChatGetPermalink,
  getChatScheduledMessagesList,
  getConversationsHistory,
  getConversationsInfo,
  getConversationsList,
  getConversationsMembers,
  getConversationsReplies,
  getDialogOpen,
  getDndInfo,
  getDndTeamInfo,
  getEmojiList,
  getFilesInfo,
  getFilesList,
  getFilesRemoteInfo,
  getFilesRemoteList,
  getFilesRemoteShare,
  getMigrationExchange,
  getOauthAccess,
  getOauthToken,
  getOauthV2Access,
  getPinsList,
  getReactionsGet,
  getReactionsList,
  getRemindersInfo,
  getRemindersList,
  getRtmConnect,
  getSearchMessages,
  getStarsList,
  getTeamAccessLogs,
  getTeamBillableInfo,
  getTeamInfo,
  getTeamIntegrationLogs,
  getTeamProfileGet,
  getUsergroupsList,
  getUsergroupsUsersList,
  getUsersConversations,
  getUsersGetPresence,
  getUsersIdentity,
  getUsersInfo,
  getUsersList,
  getUsersLookupByEmail,
  getUsersProfileGet,
  getViewsOpen,
  getViewsPublish,
  getViewsPush,
  getViewsUpdate,
  getWorkflowsStepCompleted,
  getWorkflowsStepFailed,
  getWorkflowsUpdateStep,
  postAdminAppsApprove,
  postAdminAppsRestrict,
  postAdminConversationsArchive,
  postAdminConversationsConvertToPrivate,
  postAdminConversationsCreate,
  postAdminConversationsDelete,
  postAdminConversationsDisconnectShared,
  postAdminConversationsInvite,
  postAdminConversationsRename,
  postAdminConversationsRestrictAccessAddGroup,
  postAdminConversationsRestrictAccessRemoveGroup,
  postAdminConversationsSetConversationPrefs,
  postAdminConversationsSetTeams,
  postAdminConversationsUnarchive,
  postAdminEmojiAdd,
  postAdminEmojiAddAlias,
  postAdminEmojiRemove,
  postAdminEmojiRename,
  postAdminInviteRequestsApprove,
  postAdminInviteRequestsDeny,
  postAdminTeamsCreate,
  postAdminTeamsSettingsSetDefaultChannels,
  postAdminTeamsSettingsSetDescription,
  postAdminTeamsSettingsSetDiscoverability,
  postAdminTeamsSettingsSetIcon,
  postAdminTeamsSettingsSetName,
  postAdminUsergroupsAddChannels,
  postAdminUsergroupsAddTeams,
  postAdminUsergroupsRemoveChannels,
  postAdminUsersAssign,
  postAdminUsersInvite,
  postAdminUsersRemove,
  postAdminUsersSessionInvalidate,
  postAdminUsersSessionReset,
  postAdminUsersSetAdmin,
  postAdminUsersSetExpiration,
  postAdminUsersSetOwner,
  postAdminUsersSetRegular,
  postCallsAdd,
  postCallsEnd,
  postCallsParticipantsAdd,
  postCallsParticipantsRemove,
  postCallsUpdate,
  postChatDelete,
  postChatDeleteScheduledMessage,
  postChatMeMessage,
  postChatPostEphemeral,
  postChatPostMessage,
  postChatScheduleMessage,
  postChatUnfurl,
  postChatUpdate,
  postConversationsArchive,
  postConversationsClose,
  postConversationsCreate,
  postConversationsInvite,
  postConversationsJoin,
  postConversationsKick,
  postConversationsLeave,
  postConversationsMark,
  postConversationsOpen,
  postConversationsRename,
  postConversationsSetPurpose,
  postConversationsSetTopic,
  postConversationsUnarchive,
  postDndEndDnd,
  postDndEndSnooze,
  postDndSetSnooze,
  postFilesCommentsDelete,
  postFilesDelete,
  postFilesRemoteAdd,
  postFilesRemoteRemove,
  postFilesRemoteUpdate,
  postFilesRevokePublicURL,
  postFilesSharedPublicURL,
  postFilesUpload,
  postPinsAdd,
  postPinsRemove,
  postReactionsAdd,
  postReactionsRemove,
  postRemindersAdd,
  postRemindersComplete,
  postRemindersDelete,
  postStarsAdd,
  postStarsRemove,
  postUsergroupsCreate,
  postUsergroupsDisable,
  postUsergroupsEnable,
  postUsergroupsUpdate,
  postUsergroupsUsersUpdate,
  postUsersDeletePhoto,
  postUsersProfileSet,
  postUsersSetActive,
  postUsersSetPhoto,
  postUsersSetPresence,
} from \\"./services\\";

const useHasMore = (
  pages: Array<SwaggerResponse<any>> | undefined,
  list: any,
  queryParams: any,
) =>
  useMemo(() => {
    if (!pages || (pages && pages.length < 1)) {
      return false;
    }

    const total = getTotal(pages);

    if (total !== undefined) {
      if (list && list.length < total) {
        return true;
      }
      return false;
    }
    if (
      paginationFlattenData([pages[pages.length - 1]])?.length ===
      getPageSize(queryParams as any)
    ) {
      return true;
    }

    return false;
  }, [pages, list, queryParams]);

export type SwaggerTypescriptMutationDefaultParams<TExtra> = {
  _extraVariables?: TExtra;
  configOverride?: AxiosRequestConfig;
};
type SwaggerTypescriptUseQueryOptions<TData> = Omit<
  UseQueryOptions<SwaggerResponse<TData>, RequestError | Error>,
  \\"queryKey\\"
>;

type SwaggerTypescriptUseMutationOptions<TData, TRequest, TExtra> =
  UseMutationOptions<
    SwaggerResponse<TData>,
    RequestError | Error,
    TRequest & SwaggerTypescriptMutationDefaultParams<TExtra>
  >;

type SwaggerTypescriptUseMutationOptionsVoid<TData, TExtra> =
  UseMutationOptions<
    SwaggerResponse<TData>,
    RequestError | Error,
    SwaggerTypescriptMutationDefaultParams<TExtra> | void
  >;
export const useGetAdminAppsApprovedList = (
  queryParams: GetAdminAppsApprovedListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminAppsApprovedList.info(
    queryParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetAdminAppsApprovedList.info = (
  queryParams: GetAdminAppsApprovedListQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getAdminAppsApprovedList.key, queryParams] as QueryKey,
    fun: () => getAdminAppsApprovedList(queryParams, configOverride),
  };
};
useGetAdminAppsApprovedList.prefetch = (
  client: QueryClient,
  queryParams: GetAdminAppsApprovedListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminAppsApprovedList.info(
    queryParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetAdminAppsRequestsList = (
  queryParams: GetAdminAppsRequestsListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminAppsRequestsList.info(
    queryParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetAdminAppsRequestsList.info = (
  queryParams: GetAdminAppsRequestsListQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getAdminAppsRequestsList.key, queryParams] as QueryKey,
    fun: () => getAdminAppsRequestsList(queryParams, configOverride),
  };
};
useGetAdminAppsRequestsList.prefetch = (
  client: QueryClient,
  queryParams: GetAdminAppsRequestsListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminAppsRequestsList.info(
    queryParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetAdminAppsRestrictedList = (
  queryParams: GetAdminAppsRestrictedListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminAppsRestrictedList.info(
    queryParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetAdminAppsRestrictedList.info = (
  queryParams: GetAdminAppsRestrictedListQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getAdminAppsRestrictedList.key, queryParams] as QueryKey,
    fun: () => getAdminAppsRestrictedList(queryParams, configOverride),
  };
};
useGetAdminAppsRestrictedList.prefetch = (
  client: QueryClient,
  queryParams: GetAdminAppsRestrictedListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminAppsRestrictedList.info(
    queryParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetAdminConversationsEkmListOriginalConnectedChannelInfo = (
  queryParams: GetAdminConversationsEkmListOriginalConnectedChannelInfoQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } =
    useGetAdminConversationsEkmListOriginalConnectedChannelInfo.info(
      queryParams,
      configOverride,
    );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetAdminConversationsEkmListOriginalConnectedChannelInfo.info = (
  queryParams: GetAdminConversationsEkmListOriginalConnectedChannelInfoQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [
      getAdminConversationsEkmListOriginalConnectedChannelInfo.key,
      queryParams,
    ] as QueryKey,
    fun: () =>
      getAdminConversationsEkmListOriginalConnectedChannelInfo(
        queryParams,
        configOverride,
      ),
  };
};
useGetAdminConversationsEkmListOriginalConnectedChannelInfo.prefetch = (
  client: QueryClient,
  queryParams: GetAdminConversationsEkmListOriginalConnectedChannelInfoQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } =
    useGetAdminConversationsEkmListOriginalConnectedChannelInfo.info(
      queryParams,
      configOverride,
    );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetAdminConversationsGetConversationPrefs = (
  queryParams: GetAdminConversationsGetConversationPrefsQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    prefs?: {
      can_thread?: { type?: string[]; user?: string[] };
      who_can_post?: { type?: string[]; user?: string[] };
    };
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminConversationsGetConversationPrefs.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetAdminConversationsGetConversationPrefs.info = (
  queryParams: GetAdminConversationsGetConversationPrefsQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [
      getAdminConversationsGetConversationPrefs.key,
      queryParams,
      headerParams,
    ] as QueryKey,
    fun: () =>
      getAdminConversationsGetConversationPrefs(
        queryParams,
        headerParams,
        configOverride,
      ),
  };
};
useGetAdminConversationsGetConversationPrefs.prefetch = (
  client: QueryClient,
  queryParams: GetAdminConversationsGetConversationPrefsQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    prefs?: {
      can_thread?: { type?: string[]; user?: string[] };
      who_can_post?: { type?: string[]; user?: string[] };
    };
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminConversationsGetConversationPrefs.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetAdminConversationsGetTeams = (
  queryParams: GetAdminConversationsGetTeamsQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    team_ids: Defs_team[];
    response_metadata?: { next_cursor: string };
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminConversationsGetTeams.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetAdminConversationsGetTeams.info = (
  queryParams: GetAdminConversationsGetTeamsQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [
      getAdminConversationsGetTeams.key,
      queryParams,
      headerParams,
    ] as QueryKey,
    fun: () =>
      getAdminConversationsGetTeams(queryParams, headerParams, configOverride),
  };
};
useGetAdminConversationsGetTeams.prefetch = (
  client: QueryClient,
  queryParams: GetAdminConversationsGetTeamsQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    team_ids: Defs_team[];
    response_metadata?: { next_cursor: string };
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminConversationsGetTeams.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetAdminConversationsRestrictAccessListGroups = (
  queryParams: GetAdminConversationsRestrictAccessListGroupsQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminConversationsRestrictAccessListGroups.info(
    queryParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetAdminConversationsRestrictAccessListGroups.info = (
  queryParams: GetAdminConversationsRestrictAccessListGroupsQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [
      getAdminConversationsRestrictAccessListGroups.key,
      queryParams,
    ] as QueryKey,
    fun: () =>
      getAdminConversationsRestrictAccessListGroups(
        queryParams,
        configOverride,
      ),
  };
};
useGetAdminConversationsRestrictAccessListGroups.prefetch = (
  client: QueryClient,
  queryParams: GetAdminConversationsRestrictAccessListGroupsQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminConversationsRestrictAccessListGroups.info(
    queryParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetAdminConversationsSearch = (
  queryParams?: GetAdminConversationsSearchQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{
    channels: Objs_channel[];
    next_cursor: string;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminConversationsSearch.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetAdminConversationsSearch.info = (
  queryParams?: GetAdminConversationsSearchQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [
      getAdminConversationsSearch.key,
      queryParams,
      headerParams,
    ] as QueryKey,
    fun: () =>
      getAdminConversationsSearch(queryParams, headerParams, configOverride),
  };
};
useGetAdminConversationsSearch.prefetch = (
  client: QueryClient,
  queryParams?: GetAdminConversationsSearchQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{
    channels: Objs_channel[];
    next_cursor: string;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminConversationsSearch.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetAdminEmojiList = (
  queryParams: GetAdminEmojiListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminEmojiList.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetAdminEmojiList.info = (
  queryParams: GetAdminEmojiListQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getAdminEmojiList.key, queryParams] as QueryKey,
    fun: () => getAdminEmojiList(queryParams, configOverride),
  };
};
useGetAdminEmojiList.prefetch = (
  client: QueryClient,
  queryParams: GetAdminEmojiListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminEmojiList.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetAdminInviteRequestsApprovedList = (
  queryParams?: GetAdminInviteRequestsApprovedListQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminInviteRequestsApprovedList.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetAdminInviteRequestsApprovedList.info = (
  queryParams?: GetAdminInviteRequestsApprovedListQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [
      getAdminInviteRequestsApprovedList.key,
      queryParams,
      headerParams,
    ] as QueryKey,
    fun: () =>
      getAdminInviteRequestsApprovedList(
        queryParams,
        headerParams,
        configOverride,
      ),
  };
};
useGetAdminInviteRequestsApprovedList.prefetch = (
  client: QueryClient,
  queryParams?: GetAdminInviteRequestsApprovedListQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminInviteRequestsApprovedList.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetAdminInviteRequestsDeniedList = (
  queryParams?: GetAdminInviteRequestsDeniedListQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminInviteRequestsDeniedList.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetAdminInviteRequestsDeniedList.info = (
  queryParams?: GetAdminInviteRequestsDeniedListQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [
      getAdminInviteRequestsDeniedList.key,
      queryParams,
      headerParams,
    ] as QueryKey,
    fun: () =>
      getAdminInviteRequestsDeniedList(
        queryParams,
        headerParams,
        configOverride,
      ),
  };
};
useGetAdminInviteRequestsDeniedList.prefetch = (
  client: QueryClient,
  queryParams?: GetAdminInviteRequestsDeniedListQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminInviteRequestsDeniedList.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetAdminInviteRequestsList = (
  queryParams?: GetAdminInviteRequestsListQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminInviteRequestsList.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetAdminInviteRequestsList.info = (
  queryParams?: GetAdminInviteRequestsListQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [
      getAdminInviteRequestsList.key,
      queryParams,
      headerParams,
    ] as QueryKey,
    fun: () =>
      getAdminInviteRequestsList(queryParams, headerParams, configOverride),
  };
};
useGetAdminInviteRequestsList.prefetch = (
  client: QueryClient,
  queryParams?: GetAdminInviteRequestsListQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminInviteRequestsList.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetAdminTeamsAdminsList = (
  queryParams: GetAdminTeamsAdminsListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminTeamsAdminsList.info(
    queryParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetAdminTeamsAdminsList.info = (
  queryParams: GetAdminTeamsAdminsListQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getAdminTeamsAdminsList.key, queryParams] as QueryKey,
    fun: () => getAdminTeamsAdminsList(queryParams, configOverride),
  };
};
useGetAdminTeamsAdminsList.prefetch = (
  client: QueryClient,
  queryParams: GetAdminTeamsAdminsListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminTeamsAdminsList.info(
    queryParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetAdminTeamsList = (
  queryParams?: GetAdminTeamsListQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminTeamsList.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetAdminTeamsList.info = (
  queryParams?: GetAdminTeamsListQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getAdminTeamsList.key, queryParams, headerParams] as QueryKey,
    fun: () => getAdminTeamsList(queryParams, headerParams, configOverride),
  };
};
useGetAdminTeamsList.prefetch = (
  client: QueryClient,
  queryParams?: GetAdminTeamsListQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminTeamsList.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetAdminTeamsOwnersList = (
  queryParams: GetAdminTeamsOwnersListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminTeamsOwnersList.info(
    queryParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetAdminTeamsOwnersList.info = (
  queryParams: GetAdminTeamsOwnersListQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getAdminTeamsOwnersList.key, queryParams] as QueryKey,
    fun: () => getAdminTeamsOwnersList(queryParams, configOverride),
  };
};
useGetAdminTeamsOwnersList.prefetch = (
  client: QueryClient,
  queryParams: GetAdminTeamsOwnersListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminTeamsOwnersList.info(
    queryParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetAdminTeamsSettingsInfo = (
  queryParams: GetAdminTeamsSettingsInfoQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminTeamsSettingsInfo.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetAdminTeamsSettingsInfo.info = (
  queryParams: GetAdminTeamsSettingsInfoQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getAdminTeamsSettingsInfo.key, queryParams, headerParams] as QueryKey,
    fun: () =>
      getAdminTeamsSettingsInfo(queryParams, headerParams, configOverride),
  };
};
useGetAdminTeamsSettingsInfo.prefetch = (
  client: QueryClient,
  queryParams: GetAdminTeamsSettingsInfoQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminTeamsSettingsInfo.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetAdminUsergroupsListChannels = (
  queryParams: GetAdminUsergroupsListChannelsQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminUsergroupsListChannels.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetAdminUsergroupsListChannels.info = (
  queryParams: GetAdminUsergroupsListChannelsQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [
      getAdminUsergroupsListChannels.key,
      queryParams,
      headerParams,
    ] as QueryKey,
    fun: () =>
      getAdminUsergroupsListChannels(queryParams, headerParams, configOverride),
  };
};
useGetAdminUsergroupsListChannels.prefetch = (
  client: QueryClient,
  queryParams: GetAdminUsergroupsListChannelsQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminUsergroupsListChannels.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetAdminUsersList = (
  queryParams: GetAdminUsersListQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminUsersList.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetAdminUsersList.info = (
  queryParams: GetAdminUsersListQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getAdminUsersList.key, queryParams, headerParams] as QueryKey,
    fun: () => getAdminUsersList(queryParams, headerParams, configOverride),
  };
};
useGetAdminUsersList.prefetch = (
  client: QueryClient,
  queryParams: GetAdminUsersListQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAdminUsersList.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetApiTest = (
  queryParams?: GetApiTestQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetApiTest.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetApiTest.info = (
  queryParams?: GetApiTestQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getApiTest.key, queryParams] as QueryKey,
    fun: () => getApiTest(queryParams, configOverride),
  };
};
useGetApiTest.prefetch = (
  client: QueryClient,
  queryParams?: GetApiTestQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetApiTest.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetAppsEventAuthorizationsList = (
  queryParams: GetAppsEventAuthorizationsListQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAppsEventAuthorizationsList.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetAppsEventAuthorizationsList.info = (
  queryParams: GetAppsEventAuthorizationsListQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [
      getAppsEventAuthorizationsList.key,
      queryParams,
      headerParams,
    ] as QueryKey,
    fun: () =>
      getAppsEventAuthorizationsList(queryParams, headerParams, configOverride),
  };
};
useGetAppsEventAuthorizationsList.prefetch = (
  client: QueryClient,
  queryParams: GetAppsEventAuthorizationsListQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAppsEventAuthorizationsList.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetAppsPermissionsInfo = (
  queryParams?: GetAppsPermissionsInfoQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    info: {
      app_home: { resources?: Objs_resources; scopes?: Objs_scopes };
      channel: { resources?: Objs_resources; scopes?: Objs_scopes };
      group: { resources?: Objs_resources; scopes?: Objs_scopes };
      im: { resources?: Objs_resources; scopes?: Objs_scopes };
      mpim: { resources?: Objs_resources; scopes?: Objs_scopes };
      team: { resources: Objs_resources; scopes: Objs_scopes };
    };
    ok: Defs_ok_true;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAppsPermissionsInfo.info(
    queryParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetAppsPermissionsInfo.info = (
  queryParams?: GetAppsPermissionsInfoQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getAppsPermissionsInfo.key, queryParams] as QueryKey,
    fun: () => getAppsPermissionsInfo(queryParams, configOverride),
  };
};
useGetAppsPermissionsInfo.prefetch = (
  client: QueryClient,
  queryParams?: GetAppsPermissionsInfoQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    info: {
      app_home: { resources?: Objs_resources; scopes?: Objs_scopes };
      channel: { resources?: Objs_resources; scopes?: Objs_scopes };
      group: { resources?: Objs_resources; scopes?: Objs_scopes };
      im: { resources?: Objs_resources; scopes?: Objs_scopes };
      mpim: { resources?: Objs_resources; scopes?: Objs_scopes };
      team: { resources: Objs_resources; scopes: Objs_scopes };
    };
    ok: Defs_ok_true;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAppsPermissionsInfo.info(
    queryParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetAppsPermissionsRequest = (
  queryParams: GetAppsPermissionsRequestQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAppsPermissionsRequest.info(
    queryParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetAppsPermissionsRequest.info = (
  queryParams: GetAppsPermissionsRequestQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getAppsPermissionsRequest.key, queryParams] as QueryKey,
    fun: () => getAppsPermissionsRequest(queryParams, configOverride),
  };
};
useGetAppsPermissionsRequest.prefetch = (
  client: QueryClient,
  queryParams: GetAppsPermissionsRequestQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAppsPermissionsRequest.info(
    queryParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetAppsPermissionsResourcesList = (
  queryParams: GetAppsPermissionsResourcesListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    resources: {
      /** An ID for a resource */
      id?: string;
      /** The type of resource the \`id\` corresponds to */
      type?: string;
    }[];
    response_metadata?: { next_cursor: string };
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAppsPermissionsResourcesList.info(
    queryParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetAppsPermissionsResourcesList.info = (
  queryParams: GetAppsPermissionsResourcesListQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getAppsPermissionsResourcesList.key, queryParams] as QueryKey,
    fun: () => getAppsPermissionsResourcesList(queryParams, configOverride),
  };
};
useGetAppsPermissionsResourcesList.prefetch = (
  client: QueryClient,
  queryParams: GetAppsPermissionsResourcesListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    resources: {
      /** An ID for a resource */
      id?: string;
      /** The type of resource the \`id\` corresponds to */
      type?: string;
    }[];
    response_metadata?: { next_cursor: string };
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAppsPermissionsResourcesList.info(
    queryParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetAppsPermissionsScopesList = (
  queryParams: GetAppsPermissionsScopesListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    scopes: {
      app_home?: Objs_scopes;
      channel?: Objs_scopes;
      group?: Objs_scopes;
      im?: Objs_scopes;
      mpim?: Objs_scopes;
      team?: Objs_scopes;
      user?: Objs_scopes;
    };
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAppsPermissionsScopesList.info(
    queryParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetAppsPermissionsScopesList.info = (
  queryParams: GetAppsPermissionsScopesListQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getAppsPermissionsScopesList.key, queryParams] as QueryKey,
    fun: () => getAppsPermissionsScopesList(queryParams, configOverride),
  };
};
useGetAppsPermissionsScopesList.prefetch = (
  client: QueryClient,
  queryParams: GetAppsPermissionsScopesListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    scopes: {
      app_home?: Objs_scopes;
      channel?: Objs_scopes;
      group?: Objs_scopes;
      im?: Objs_scopes;
      mpim?: Objs_scopes;
      team?: Objs_scopes;
      user?: Objs_scopes;
    };
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAppsPermissionsScopesList.info(
    queryParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetAppsPermissionsUsersList = (
  queryParams: GetAppsPermissionsUsersListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAppsPermissionsUsersList.info(
    queryParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetAppsPermissionsUsersList.info = (
  queryParams: GetAppsPermissionsUsersListQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getAppsPermissionsUsersList.key, queryParams] as QueryKey,
    fun: () => getAppsPermissionsUsersList(queryParams, configOverride),
  };
};
useGetAppsPermissionsUsersList.prefetch = (
  client: QueryClient,
  queryParams: GetAppsPermissionsUsersListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAppsPermissionsUsersList.info(
    queryParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetAppsPermissionsUsersRequest = (
  queryParams: GetAppsPermissionsUsersRequestQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAppsPermissionsUsersRequest.info(
    queryParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetAppsPermissionsUsersRequest.info = (
  queryParams: GetAppsPermissionsUsersRequestQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getAppsPermissionsUsersRequest.key, queryParams] as QueryKey,
    fun: () => getAppsPermissionsUsersRequest(queryParams, configOverride),
  };
};
useGetAppsPermissionsUsersRequest.prefetch = (
  client: QueryClient,
  queryParams: GetAppsPermissionsUsersRequestQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAppsPermissionsUsersRequest.info(
    queryParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetAppsUninstall = (
  queryParams?: GetAppsUninstallQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAppsUninstall.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetAppsUninstall.info = (
  queryParams?: GetAppsUninstallQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getAppsUninstall.key, queryParams] as QueryKey,
    fun: () => getAppsUninstall(queryParams, configOverride),
  };
};
useGetAppsUninstall.prefetch = (
  client: QueryClient,
  queryParams?: GetAppsUninstallQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAppsUninstall.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetAuthRevoke = (
  queryParams: GetAuthRevokeQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    revoked: boolean;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAuthRevoke.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetAuthRevoke.info = (
  queryParams: GetAuthRevokeQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getAuthRevoke.key, queryParams] as QueryKey,
    fun: () => getAuthRevoke(queryParams, configOverride),
  };
};
useGetAuthRevoke.prefetch = (
  client: QueryClient,
  queryParams: GetAuthRevokeQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    revoked: boolean;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAuthRevoke.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetAuthTest = (
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    team: string;
    team_id: Defs_team;
    url: string;
    user: string;
    user_id: Defs_user_id;
    bot_id?: Defs_bot_id;
    is_enterprise_install?: boolean;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAuthTest.info(headerParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetAuthTest.info = (
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getAuthTest.key, headerParams] as QueryKey,
    fun: () => getAuthTest(headerParams, configOverride),
  };
};
useGetAuthTest.prefetch = (
  client: QueryClient,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    team: string;
    team_id: Defs_team;
    url: string;
    user: string;
    user_id: Defs_user_id;
    bot_id?: Defs_bot_id;
    is_enterprise_install?: boolean;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetAuthTest.info(headerParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetBotsInfo = (
  queryParams: GetBotsInfoQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    bot: {
      app_id: Defs_app_id;
      deleted: boolean;
      icons: {
        /** - Format: uri */
        image_36: string;
        /** - Format: uri */
        image_48: string;
        /** - Format: uri */
        image_72: string;
      };
      id: Defs_bot_id;
      name: string;
      updated: number;
      user_id?: Defs_user_id;
    };
    ok: Defs_ok_true;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetBotsInfo.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetBotsInfo.info = (
  queryParams: GetBotsInfoQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getBotsInfo.key, queryParams] as QueryKey,
    fun: () => getBotsInfo(queryParams, configOverride),
  };
};
useGetBotsInfo.prefetch = (
  client: QueryClient,
  queryParams: GetBotsInfoQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    bot: {
      app_id: Defs_app_id;
      deleted: boolean;
      icons: {
        /** - Format: uri */
        image_36: string;
        /** - Format: uri */
        image_48: string;
        /** - Format: uri */
        image_72: string;
      };
      id: Defs_bot_id;
      name: string;
      updated: number;
      user_id?: Defs_user_id;
    };
    ok: Defs_ok_true;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetBotsInfo.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetCallsInfo = (
  queryParams: GetCallsInfoQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetCallsInfo.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetCallsInfo.info = (
  queryParams: GetCallsInfoQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getCallsInfo.key, queryParams, headerParams] as QueryKey,
    fun: () => getCallsInfo(queryParams, headerParams, configOverride),
  };
};
useGetCallsInfo.prefetch = (
  client: QueryClient,
  queryParams: GetCallsInfoQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetCallsInfo.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetChatGetPermalink = (
  queryParams: GetChatGetPermalinkQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    channel: Defs_channel;
    ok: Defs_ok_true;
    /** - Format: uri */
    permalink: string;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetChatGetPermalink.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetChatGetPermalink.info = (
  queryParams: GetChatGetPermalinkQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getChatGetPermalink.key, queryParams] as QueryKey,
    fun: () => getChatGetPermalink(queryParams, configOverride),
  };
};
useGetChatGetPermalink.prefetch = (
  client: QueryClient,
  queryParams: GetChatGetPermalinkQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    channel: Defs_channel;
    ok: Defs_ok_true;
    /** - Format: uri */
    permalink: string;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetChatGetPermalink.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetChatScheduledMessagesList = (
  queryParams?: GetChatScheduledMessagesListQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    response_metadata: { next_cursor: string };
    scheduled_messages: {
      channel_id: Defs_channel_id;
      /** - Pattern: ^\\\\d{10}$ */
      date_created: number;
      /** - Pattern: ^[Q][A-Z0-9]{8,}$ */
      id: string;
      /** - Pattern: ^\\\\d{10}$ */
      post_at: number;
      text?: string;
    }[];
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetChatScheduledMessagesList.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetChatScheduledMessagesList.info = (
  queryParams?: GetChatScheduledMessagesListQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [
      getChatScheduledMessagesList.key,
      queryParams,
      headerParams,
    ] as QueryKey,
    fun: () =>
      getChatScheduledMessagesList(queryParams, headerParams, configOverride),
  };
};
useGetChatScheduledMessagesList.prefetch = (
  client: QueryClient,
  queryParams?: GetChatScheduledMessagesListQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    response_metadata: { next_cursor: string };
    scheduled_messages: {
      channel_id: Defs_channel_id;
      /** - Pattern: ^\\\\d{10}$ */
      date_created: number;
      /** - Pattern: ^[Q][A-Z0-9]{8,}$ */
      id: string;
      /** - Pattern: ^\\\\d{10}$ */
      post_at: number;
      text?: string;
    }[];
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetChatScheduledMessagesList.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetConversationsHistory = (
  queryParams?: GetConversationsHistoryQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    channel_actions_count: number;
    channel_actions_ts: (number | null)[];
    has_more: boolean;
    messages: Objs_message[];
    ok: Defs_ok_true;
    pin_count: number;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetConversationsHistory.info(
    queryParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetConversationsHistory.info = (
  queryParams?: GetConversationsHistoryQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getConversationsHistory.key, queryParams] as QueryKey,
    fun: () => getConversationsHistory(queryParams, configOverride),
  };
};
useGetConversationsHistory.prefetch = (
  client: QueryClient,
  queryParams?: GetConversationsHistoryQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    channel_actions_count: number;
    channel_actions_ts: (number | null)[];
    has_more: boolean;
    messages: Objs_message[];
    ok: Defs_ok_true;
    pin_count: number;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetConversationsHistory.info(
    queryParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetConversationsInfo = (
  queryParams?: GetConversationsInfoQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    channel: Objs_conversation;
    ok: Defs_ok_true;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetConversationsInfo.info(
    queryParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetConversationsInfo.info = (
  queryParams?: GetConversationsInfoQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getConversationsInfo.key, queryParams] as QueryKey,
    fun: () => getConversationsInfo(queryParams, configOverride),
  };
};
useGetConversationsInfo.prefetch = (
  client: QueryClient,
  queryParams?: GetConversationsInfoQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    channel: Objs_conversation;
    ok: Defs_ok_true;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetConversationsInfo.info(
    queryParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetConversationsList = (
  queryParams?: GetConversationsListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    channels: Objs_conversation[];
    ok: Defs_ok_true;
    response_metadata?: { next_cursor: string };
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetConversationsList.info(
    queryParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetConversationsList.info = (
  queryParams?: GetConversationsListQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getConversationsList.key, queryParams] as QueryKey,
    fun: () => getConversationsList(queryParams, configOverride),
  };
};
useGetConversationsList.prefetch = (
  client: QueryClient,
  queryParams?: GetConversationsListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    channels: Objs_conversation[];
    ok: Defs_ok_true;
    response_metadata?: { next_cursor: string };
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetConversationsList.info(
    queryParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetConversationsMembers = (
  queryParams?: GetConversationsMembersQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    members: Defs_user_id[];
    ok: Defs_ok_true;
    response_metadata: { next_cursor: string };
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetConversationsMembers.info(
    queryParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetConversationsMembers.info = (
  queryParams?: GetConversationsMembersQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getConversationsMembers.key, queryParams] as QueryKey,
    fun: () => getConversationsMembers(queryParams, configOverride),
  };
};
useGetConversationsMembers.prefetch = (
  client: QueryClient,
  queryParams?: GetConversationsMembersQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    members: Defs_user_id[];
    ok: Defs_ok_true;
    response_metadata: { next_cursor: string };
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetConversationsMembers.info(
    queryParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetConversationsReplies = (
  queryParams?: GetConversationsRepliesQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    messages: (
      | {
          reply_count: number;
          subscribed: boolean;
          text: string;
          thread_ts: Defs_ts;
          ts: Defs_ts;
          type: string;
          user: Defs_user_id;
          last_read?: Defs_ts;
          latest_reply?: Defs_ts;
          reply_users?: Defs_user_id[];
          reply_users_count?: number;
          source_team?: Defs_team;
          team?: Defs_team;
          unread_count?: number;
          user_profile?: Objs_user_profile_short;
          user_team?: Defs_team;
        }
      | {
          parent_user_id: Defs_user_id;
          text: string;
          thread_ts: Defs_ts;
          ts: Defs_ts;
          type: string;
          user: Defs_user_id;
          is_starred?: boolean;
          source_team?: Defs_team;
          team?: Defs_team;
          user_profile?: Objs_user_profile_short;
          user_team?: Defs_team;
        }
    )[][];
    ok: Defs_ok_true;
    has_more?: boolean;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetConversationsReplies.info(
    queryParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetConversationsReplies.info = (
  queryParams?: GetConversationsRepliesQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getConversationsReplies.key, queryParams] as QueryKey,
    fun: () => getConversationsReplies(queryParams, configOverride),
  };
};
useGetConversationsReplies.prefetch = (
  client: QueryClient,
  queryParams?: GetConversationsRepliesQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    messages: (
      | {
          reply_count: number;
          subscribed: boolean;
          text: string;
          thread_ts: Defs_ts;
          ts: Defs_ts;
          type: string;
          user: Defs_user_id;
          last_read?: Defs_ts;
          latest_reply?: Defs_ts;
          reply_users?: Defs_user_id[];
          reply_users_count?: number;
          source_team?: Defs_team;
          team?: Defs_team;
          unread_count?: number;
          user_profile?: Objs_user_profile_short;
          user_team?: Defs_team;
        }
      | {
          parent_user_id: Defs_user_id;
          text: string;
          thread_ts: Defs_ts;
          ts: Defs_ts;
          type: string;
          user: Defs_user_id;
          is_starred?: boolean;
          source_team?: Defs_team;
          team?: Defs_team;
          user_profile?: Objs_user_profile_short;
          user_team?: Defs_team;
        }
    )[][];
    ok: Defs_ok_true;
    has_more?: boolean;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetConversationsReplies.info(
    queryParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetDialogOpen = (
  queryParams: GetDialogOpenQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetDialogOpen.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetDialogOpen.info = (
  queryParams: GetDialogOpenQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getDialogOpen.key, queryParams, headerParams] as QueryKey,
    fun: () => getDialogOpen(queryParams, headerParams, configOverride),
  };
};
useGetDialogOpen.prefetch = (
  client: QueryClient,
  queryParams: GetDialogOpenQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetDialogOpen.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetDndInfo = (
  queryParams?: GetDndInfoQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    dnd_enabled: boolean;
    next_dnd_end_ts: number;
    next_dnd_start_ts: number;
    ok: Defs_ok_true;
    snooze_enabled?: boolean;
    snooze_endtime?: number;
    snooze_remaining?: number;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetDndInfo.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetDndInfo.info = (
  queryParams?: GetDndInfoQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getDndInfo.key, queryParams] as QueryKey,
    fun: () => getDndInfo(queryParams, configOverride),
  };
};
useGetDndInfo.prefetch = (
  client: QueryClient,
  queryParams?: GetDndInfoQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    dnd_enabled: boolean;
    next_dnd_end_ts: number;
    next_dnd_start_ts: number;
    ok: Defs_ok_true;
    snooze_enabled?: boolean;
    snooze_endtime?: number;
    snooze_remaining?: number;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetDndInfo.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetDndTeamInfo = (
  queryParams?: GetDndTeamInfoQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetDndTeamInfo.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetDndTeamInfo.info = (
  queryParams?: GetDndTeamInfoQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getDndTeamInfo.key, queryParams] as QueryKey,
    fun: () => getDndTeamInfo(queryParams, configOverride),
  };
};
useGetDndTeamInfo.prefetch = (
  client: QueryClient,
  queryParams?: GetDndTeamInfoQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetDndTeamInfo.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetEmojiList = (
  queryParams: GetEmojiListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetEmojiList.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetEmojiList.info = (
  queryParams: GetEmojiListQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getEmojiList.key, queryParams] as QueryKey,
    fun: () => getEmojiList(queryParams, configOverride),
  };
};
useGetEmojiList.prefetch = (
  client: QueryClient,
  queryParams: GetEmojiListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetEmojiList.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetFilesInfo = (
  queryParams?: GetFilesInfoQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    comments: Objs_comments;
    file: Objs_file;
    ok: Defs_ok_true;
    content_html?: null;
    editor?: Defs_user_id;
    paging?: Objs_paging;
    response_metadata?: Objs_response_metadata;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetFilesInfo.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetFilesInfo.info = (
  queryParams?: GetFilesInfoQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getFilesInfo.key, queryParams] as QueryKey,
    fun: () => getFilesInfo(queryParams, configOverride),
  };
};
useGetFilesInfo.prefetch = (
  client: QueryClient,
  queryParams?: GetFilesInfoQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    comments: Objs_comments;
    file: Objs_file;
    ok: Defs_ok_true;
    content_html?: null;
    editor?: Defs_user_id;
    paging?: Objs_paging;
    response_metadata?: Objs_response_metadata;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetFilesInfo.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetFilesList = (
  queryParams?: GetFilesListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    files: Objs_file[];
    ok: Defs_ok_true;
    paging: Objs_paging;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetFilesList.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetFilesList.info = (
  queryParams?: GetFilesListQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getFilesList.key, queryParams] as QueryKey,
    fun: () => getFilesList(queryParams, configOverride),
  };
};
useGetFilesList.prefetch = (
  client: QueryClient,
  queryParams?: GetFilesListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    files: Objs_file[];
    ok: Defs_ok_true;
    paging: Objs_paging;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetFilesList.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetFilesRemoteInfo = (
  queryParams?: GetFilesRemoteInfoQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetFilesRemoteInfo.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetFilesRemoteInfo.info = (
  queryParams?: GetFilesRemoteInfoQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getFilesRemoteInfo.key, queryParams] as QueryKey,
    fun: () => getFilesRemoteInfo(queryParams, configOverride),
  };
};
useGetFilesRemoteInfo.prefetch = (
  client: QueryClient,
  queryParams?: GetFilesRemoteInfoQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetFilesRemoteInfo.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetFilesRemoteList = (
  queryParams?: GetFilesRemoteListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetFilesRemoteList.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetFilesRemoteList.info = (
  queryParams?: GetFilesRemoteListQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getFilesRemoteList.key, queryParams] as QueryKey,
    fun: () => getFilesRemoteList(queryParams, configOverride),
  };
};
useGetFilesRemoteList.prefetch = (
  client: QueryClient,
  queryParams?: GetFilesRemoteListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetFilesRemoteList.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetFilesRemoteShare = (
  queryParams?: GetFilesRemoteShareQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetFilesRemoteShare.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetFilesRemoteShare.info = (
  queryParams?: GetFilesRemoteShareQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getFilesRemoteShare.key, queryParams] as QueryKey,
    fun: () => getFilesRemoteShare(queryParams, configOverride),
  };
};
useGetFilesRemoteShare.prefetch = (
  client: QueryClient,
  queryParams?: GetFilesRemoteShareQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetFilesRemoteShare.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetMigrationExchange = (
  queryParams: GetMigrationExchangeQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    /** The enterprise grid organization ID containing the workspace/team. */
    enterprise_id: string;
    ok: Defs_ok_true;
    team_id: Defs_team;
    /** A list of User IDs that cannot be mapped or found */
    invalid_user_ids?: string[];
    /** A mapping of provided user IDs with mapped user IDs */
    user_id_map?: { [x: string]: any };
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetMigrationExchange.info(
    queryParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetMigrationExchange.info = (
  queryParams: GetMigrationExchangeQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getMigrationExchange.key, queryParams] as QueryKey,
    fun: () => getMigrationExchange(queryParams, configOverride),
  };
};
useGetMigrationExchange.prefetch = (
  client: QueryClient,
  queryParams: GetMigrationExchangeQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    /** The enterprise grid organization ID containing the workspace/team. */
    enterprise_id: string;
    ok: Defs_ok_true;
    team_id: Defs_team;
    /** A list of User IDs that cannot be mapped or found */
    invalid_user_ids?: string[];
    /** A mapping of provided user IDs with mapped user IDs */
    user_id_map?: { [x: string]: any };
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetMigrationExchange.info(
    queryParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetOauthAccess = (
  queryParams?: GetOauthAccessQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetOauthAccess.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetOauthAccess.info = (
  queryParams?: GetOauthAccessQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getOauthAccess.key, queryParams] as QueryKey,
    fun: () => getOauthAccess(queryParams, configOverride),
  };
};
useGetOauthAccess.prefetch = (
  client: QueryClient,
  queryParams?: GetOauthAccessQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetOauthAccess.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetOauthToken = (
  queryParams?: GetOauthTokenQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetOauthToken.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetOauthToken.info = (
  queryParams?: GetOauthTokenQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getOauthToken.key, queryParams] as QueryKey,
    fun: () => getOauthToken(queryParams, configOverride),
  };
};
useGetOauthToken.prefetch = (
  client: QueryClient,
  queryParams?: GetOauthTokenQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetOauthToken.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetOauthV2Access = (
  queryParams: GetOauthV2AccessQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetOauthV2Access.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetOauthV2Access.info = (
  queryParams: GetOauthV2AccessQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getOauthV2Access.key, queryParams] as QueryKey,
    fun: () => getOauthV2Access(queryParams, configOverride),
  };
};
useGetOauthV2Access.prefetch = (
  client: QueryClient,
  queryParams: GetOauthV2AccessQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetOauthV2Access.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetPinsList = (
  queryParams: GetPinsListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<
    (
      | {
          items: (
            | {
                created?: number;
                created_by?: Defs_user_id;
                file?: Objs_file;
                type?: \\"file\\";
              }
            | {
                channel?: Defs_channel;
                created?: number;
                created_by?: Defs_user_id;
                message?: Objs_message;
                type?: \\"message\\";
              }
          )[];
          ok: Defs_ok_true;
        }
      | { count: number; ok: Defs_ok_true }
    )[]
  >,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetPinsList.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetPinsList.info = (
  queryParams: GetPinsListQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getPinsList.key, queryParams] as QueryKey,
    fun: () => getPinsList(queryParams, configOverride),
  };
};
useGetPinsList.prefetch = (
  client: QueryClient,
  queryParams: GetPinsListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<
    (
      | {
          items: (
            | {
                created?: number;
                created_by?: Defs_user_id;
                file?: Objs_file;
                type?: \\"file\\";
              }
            | {
                channel?: Defs_channel;
                created?: number;
                created_by?: Defs_user_id;
                message?: Objs_message;
                type?: \\"message\\";
              }
          )[];
          ok: Defs_ok_true;
        }
      | { count: number; ok: Defs_ok_true }
    )[]
  >,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetPinsList.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetReactionsGet = (
  queryParams: GetReactionsGetQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<
    (
      | {
          channel: Defs_channel;
          message: Objs_message;
          ok: Defs_ok_true;
          type: \\"message\\";
        }
      | { file: Objs_file; ok: Defs_ok_true; type: \\"file\\" }
      | {
          comment: Objs_comment;
          file: Objs_file;
          ok: Defs_ok_true;
          type: \\"file_comment\\";
        }
    )[]
  >,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetReactionsGet.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetReactionsGet.info = (
  queryParams: GetReactionsGetQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getReactionsGet.key, queryParams] as QueryKey,
    fun: () => getReactionsGet(queryParams, configOverride),
  };
};
useGetReactionsGet.prefetch = (
  client: QueryClient,
  queryParams: GetReactionsGetQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<
    (
      | {
          channel: Defs_channel;
          message: Objs_message;
          ok: Defs_ok_true;
          type: \\"message\\";
        }
      | { file: Objs_file; ok: Defs_ok_true; type: \\"file\\" }
      | {
          comment: Objs_comment;
          file: Objs_file;
          ok: Defs_ok_true;
          type: \\"file_comment\\";
        }
    )[]
  >,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetReactionsGet.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetReactionsList = (
  queryParams: GetReactionsListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    items: (
      | { channel: Defs_channel; message: Objs_message; type: \\"message\\" }
      | { file: Objs_file; type: \\"file\\" }
      | { comment: Objs_comment; file: Objs_file; type: \\"file_comment\\" }
    )[][];
    ok: Defs_ok_true;
    paging?: Objs_paging;
    response_metadata?: Objs_response_metadata;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetReactionsList.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetReactionsList.info = (
  queryParams: GetReactionsListQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getReactionsList.key, queryParams] as QueryKey,
    fun: () => getReactionsList(queryParams, configOverride),
  };
};
useGetReactionsList.prefetch = (
  client: QueryClient,
  queryParams: GetReactionsListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    items: (
      | { channel: Defs_channel; message: Objs_message; type: \\"message\\" }
      | { file: Objs_file; type: \\"file\\" }
      | { comment: Objs_comment; file: Objs_file; type: \\"file_comment\\" }
    )[][];
    ok: Defs_ok_true;
    paging?: Objs_paging;
    response_metadata?: Objs_response_metadata;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetReactionsList.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetRemindersInfo = (
  queryParams?: GetRemindersInfoQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    reminder: Objs_reminder;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetRemindersInfo.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetRemindersInfo.info = (
  queryParams?: GetRemindersInfoQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getRemindersInfo.key, queryParams] as QueryKey,
    fun: () => getRemindersInfo(queryParams, configOverride),
  };
};
useGetRemindersInfo.prefetch = (
  client: QueryClient,
  queryParams?: GetRemindersInfoQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    reminder: Objs_reminder;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetRemindersInfo.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetRemindersList = (
  queryParams?: GetRemindersListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    reminders: Objs_reminder[];
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetRemindersList.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetRemindersList.info = (
  queryParams?: GetRemindersListQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getRemindersList.key, queryParams] as QueryKey,
    fun: () => getRemindersList(queryParams, configOverride),
  };
};
useGetRemindersList.prefetch = (
  client: QueryClient,
  queryParams?: GetRemindersListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    reminders: Objs_reminder[];
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetRemindersList.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetRtmConnect = (
  queryParams: GetRtmConnectQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    self: { id: Defs_user_id; name: string };
    team: { domain: string; id: Defs_team; name: string };
    /** - Format: uri */
    url: string;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetRtmConnect.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetRtmConnect.info = (
  queryParams: GetRtmConnectQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getRtmConnect.key, queryParams] as QueryKey,
    fun: () => getRtmConnect(queryParams, configOverride),
  };
};
useGetRtmConnect.prefetch = (
  client: QueryClient,
  queryParams: GetRtmConnectQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    self: { id: Defs_user_id; name: string };
    team: { domain: string; id: Defs_team; name: string };
    /** - Format: uri */
    url: string;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetRtmConnect.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetSearchMessages = (
  queryParams: GetSearchMessagesQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetSearchMessages.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetSearchMessages.info = (
  queryParams: GetSearchMessagesQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getSearchMessages.key, queryParams] as QueryKey,
    fun: () => getSearchMessages(queryParams, configOverride),
  };
};
useGetSearchMessages.prefetch = (
  client: QueryClient,
  queryParams: GetSearchMessagesQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetSearchMessages.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetStarsList = (
  queryParams?: GetStarsListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    items: (
      | {
          channel: Defs_channel;
          date_create: number;
          message: Objs_message;
          type: \\"message\\";
        }
      | { date_create: number; file: Objs_file; type: \\"file\\" }
      | {
          comment: Objs_comment;
          date_create: number;
          file: Objs_file;
          type: \\"file_comment\\";
        }
      | { channel: Defs_channel; date_create: number; type: \\"channel\\" }
      | { channel: Defs_dm_id; date_create: number; type: \\"im\\" }
      | { channel: Defs_group_id; date_create: number; type: \\"group\\" }
    )[][];
    ok: Defs_ok_true;
    paging?: Objs_paging;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetStarsList.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetStarsList.info = (
  queryParams?: GetStarsListQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getStarsList.key, queryParams] as QueryKey,
    fun: () => getStarsList(queryParams, configOverride),
  };
};
useGetStarsList.prefetch = (
  client: QueryClient,
  queryParams?: GetStarsListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    items: (
      | {
          channel: Defs_channel;
          date_create: number;
          message: Objs_message;
          type: \\"message\\";
        }
      | { date_create: number; file: Objs_file; type: \\"file\\" }
      | {
          comment: Objs_comment;
          date_create: number;
          file: Objs_file;
          type: \\"file_comment\\";
        }
      | { channel: Defs_channel; date_create: number; type: \\"channel\\" }
      | { channel: Defs_dm_id; date_create: number; type: \\"im\\" }
      | { channel: Defs_group_id; date_create: number; type: \\"group\\" }
    )[][];
    ok: Defs_ok_true;
    paging?: Objs_paging;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetStarsList.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetTeamAccessLogs = (
  queryParams: GetTeamAccessLogsQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    logins: {
      count: number;
      date_first: number;
      date_last: number;
      user_agent: string;
      user_id: Defs_user_id;
      username: string;
      country?: string;
      ip?: string;
      isp?: string;
      region?: string;
    }[];
    ok: Defs_ok_true;
    paging: Objs_paging;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetTeamAccessLogs.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetTeamAccessLogs.info = (
  queryParams: GetTeamAccessLogsQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getTeamAccessLogs.key, queryParams] as QueryKey,
    fun: () => getTeamAccessLogs(queryParams, configOverride),
  };
};
useGetTeamAccessLogs.prefetch = (
  client: QueryClient,
  queryParams: GetTeamAccessLogsQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    logins: {
      count: number;
      date_first: number;
      date_last: number;
      user_agent: string;
      user_id: Defs_user_id;
      username: string;
      country?: string;
      ip?: string;
      isp?: string;
      region?: string;
    }[];
    ok: Defs_ok_true;
    paging: Objs_paging;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetTeamAccessLogs.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetTeamBillableInfo = (
  queryParams: GetTeamBillableInfoQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetTeamBillableInfo.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetTeamBillableInfo.info = (
  queryParams: GetTeamBillableInfoQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getTeamBillableInfo.key, queryParams] as QueryKey,
    fun: () => getTeamBillableInfo(queryParams, configOverride),
  };
};
useGetTeamBillableInfo.prefetch = (
  client: QueryClient,
  queryParams: GetTeamBillableInfoQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetTeamBillableInfo.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetTeamInfo = (
  queryParams: GetTeamInfoQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    team: Objs_team;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetTeamInfo.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetTeamInfo.info = (
  queryParams: GetTeamInfoQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getTeamInfo.key, queryParams] as QueryKey,
    fun: () => getTeamInfo(queryParams, configOverride),
  };
};
useGetTeamInfo.prefetch = (
  client: QueryClient,
  queryParams: GetTeamInfoQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    team: Objs_team;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetTeamInfo.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetTeamIntegrationLogs = (
  queryParams: GetTeamIntegrationLogsQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    logs: {
      app_id: Defs_app_id;
      app_type: string;
      change_type: string;
      date: string;
      scope: string;
      user_id: Defs_user_id;
      user_name: string;
      admin_app_id?: Defs_app_id;
      channel?: Defs_channel;
      service_id?: string;
      service_type?: string;
    }[];
    ok: Defs_ok_true;
    paging: Objs_paging;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetTeamIntegrationLogs.info(
    queryParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetTeamIntegrationLogs.info = (
  queryParams: GetTeamIntegrationLogsQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getTeamIntegrationLogs.key, queryParams] as QueryKey,
    fun: () => getTeamIntegrationLogs(queryParams, configOverride),
  };
};
useGetTeamIntegrationLogs.prefetch = (
  client: QueryClient,
  queryParams: GetTeamIntegrationLogsQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    logs: {
      app_id: Defs_app_id;
      app_type: string;
      change_type: string;
      date: string;
      scope: string;
      user_id: Defs_user_id;
      user_name: string;
      admin_app_id?: Defs_app_id;
      channel?: Defs_channel;
      service_id?: string;
      service_type?: string;
    }[];
    ok: Defs_ok_true;
    paging: Objs_paging;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetTeamIntegrationLogs.info(
    queryParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetTeamProfileGet = (
  queryParams: GetTeamProfileGetQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    profile: { fields: Objs_team_profile_field[] };
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetTeamProfileGet.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetTeamProfileGet.info = (
  queryParams: GetTeamProfileGetQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getTeamProfileGet.key, queryParams] as QueryKey,
    fun: () => getTeamProfileGet(queryParams, configOverride),
  };
};
useGetTeamProfileGet.prefetch = (
  client: QueryClient,
  queryParams: GetTeamProfileGetQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    profile: { fields: Objs_team_profile_field[] };
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetTeamProfileGet.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetUsergroupsList = (
  queryParams: GetUsergroupsListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    usergroups: Objs_subteam[];
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetUsergroupsList.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetUsergroupsList.info = (
  queryParams: GetUsergroupsListQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getUsergroupsList.key, queryParams] as QueryKey,
    fun: () => getUsergroupsList(queryParams, configOverride),
  };
};
useGetUsergroupsList.prefetch = (
  client: QueryClient,
  queryParams: GetUsergroupsListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    usergroups: Objs_subteam[];
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetUsergroupsList.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetUsergroupsUsersList = (
  queryParams: GetUsergroupsUsersListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    users: Defs_user_id[];
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetUsergroupsUsersList.info(
    queryParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetUsergroupsUsersList.info = (
  queryParams: GetUsergroupsUsersListQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getUsergroupsUsersList.key, queryParams] as QueryKey,
    fun: () => getUsergroupsUsersList(queryParams, configOverride),
  };
};
useGetUsergroupsUsersList.prefetch = (
  client: QueryClient,
  queryParams: GetUsergroupsUsersListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    users: Defs_user_id[];
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetUsergroupsUsersList.info(
    queryParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetUsersConversations = (
  queryParams?: GetUsersConversationsQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    channels: Objs_conversation[];
    ok: Defs_ok_true;
    response_metadata?: { next_cursor: string };
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetUsersConversations.info(
    queryParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetUsersConversations.info = (
  queryParams?: GetUsersConversationsQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getUsersConversations.key, queryParams] as QueryKey,
    fun: () => getUsersConversations(queryParams, configOverride),
  };
};
useGetUsersConversations.prefetch = (
  client: QueryClient,
  queryParams?: GetUsersConversationsQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    channels: Objs_conversation[];
    ok: Defs_ok_true;
    response_metadata?: { next_cursor: string };
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetUsersConversations.info(
    queryParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetUsersGetPresence = (
  queryParams: GetUsersGetPresenceQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    presence: string;
    auto_away?: boolean;
    connection_count?: number;
    last_activity?: number;
    manual_away?: boolean;
    online?: boolean;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetUsersGetPresence.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetUsersGetPresence.info = (
  queryParams: GetUsersGetPresenceQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getUsersGetPresence.key, queryParams] as QueryKey,
    fun: () => getUsersGetPresence(queryParams, configOverride),
  };
};
useGetUsersGetPresence.prefetch = (
  client: QueryClient,
  queryParams: GetUsersGetPresenceQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    presence: string;
    auto_away?: boolean;
    connection_count?: number;
    last_activity?: number;
    manual_away?: boolean;
    online?: boolean;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetUsersGetPresence.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetUsersIdentity = (
  queryParams?: GetUsersIdentityQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<
    (
      | {
          ok: Defs_ok_true;
          team: { id: Defs_team };
          user: { id: Defs_user_id; name: string };
        }
      | {
          ok: Defs_ok_true;
          team: { id: Defs_team };
          user: {
            /** - Format: email */
            email: string;
            id: Defs_user_id;
            name: string;
          };
        }
      | {
          ok: Defs_ok_true;
          team: { id: Defs_team };
          user: {
            id: Defs_user_id;
            /** - Format: url */
            image_192: string;
            /** - Format: url */
            image_24: string;
            /** - Format: url */
            image_32: string;
            /** - Format: url */
            image_48: string;
            /** - Format: url */
            image_512: string;
            /** - Format: url */
            image_72: string;
            name: string;
          };
        }
      | {
          ok: Defs_ok_true;
          team: {
            domain: string;
            id: Defs_team;
            /** - Format: url */
            image_102: string;
            /** - Format: url */
            image_132: string;
            /** - Format: url */
            image_230: string;
            /** - Format: url */
            image_34: string;
            /** - Format: url */
            image_44: string;
            /** - Format: url */
            image_68: string;
            /** - Format: url */
            image_88: string;
            image_default: boolean;
            name: string;
          };
          user: { id: Defs_user_id; name: string };
        }
    )[]
  >,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetUsersIdentity.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetUsersIdentity.info = (
  queryParams?: GetUsersIdentityQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getUsersIdentity.key, queryParams] as QueryKey,
    fun: () => getUsersIdentity(queryParams, configOverride),
  };
};
useGetUsersIdentity.prefetch = (
  client: QueryClient,
  queryParams?: GetUsersIdentityQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<
    (
      | {
          ok: Defs_ok_true;
          team: { id: Defs_team };
          user: { id: Defs_user_id; name: string };
        }
      | {
          ok: Defs_ok_true;
          team: { id: Defs_team };
          user: {
            /** - Format: email */
            email: string;
            id: Defs_user_id;
            name: string;
          };
        }
      | {
          ok: Defs_ok_true;
          team: { id: Defs_team };
          user: {
            id: Defs_user_id;
            /** - Format: url */
            image_192: string;
            /** - Format: url */
            image_24: string;
            /** - Format: url */
            image_32: string;
            /** - Format: url */
            image_48: string;
            /** - Format: url */
            image_512: string;
            /** - Format: url */
            image_72: string;
            name: string;
          };
        }
      | {
          ok: Defs_ok_true;
          team: {
            domain: string;
            id: Defs_team;
            /** - Format: url */
            image_102: string;
            /** - Format: url */
            image_132: string;
            /** - Format: url */
            image_230: string;
            /** - Format: url */
            image_34: string;
            /** - Format: url */
            image_44: string;
            /** - Format: url */
            image_68: string;
            /** - Format: url */
            image_88: string;
            image_default: boolean;
            name: string;
          };
          user: { id: Defs_user_id; name: string };
        }
    )[]
  >,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetUsersIdentity.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetUsersInfo = (
  queryParams: GetUsersInfoQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    user: Objs_user;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetUsersInfo.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetUsersInfo.info = (
  queryParams: GetUsersInfoQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getUsersInfo.key, queryParams] as QueryKey,
    fun: () => getUsersInfo(queryParams, configOverride),
  };
};
useGetUsersInfo.prefetch = (
  client: QueryClient,
  queryParams: GetUsersInfoQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    user: Objs_user;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetUsersInfo.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetUsersList = (
  queryParams?: GetUsersListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    cache_ts: number;
    members: Objs_user[];
    ok: Defs_ok_true;
    response_metadata?: Objs_response_metadata;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetUsersList.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetUsersList.info = (
  queryParams?: GetUsersListQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getUsersList.key, queryParams] as QueryKey,
    fun: () => getUsersList(queryParams, configOverride),
  };
};
useGetUsersList.prefetch = (
  client: QueryClient,
  queryParams?: GetUsersListQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    cache_ts: number;
    members: Objs_user[];
    ok: Defs_ok_true;
    response_metadata?: Objs_response_metadata;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetUsersList.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetUsersLookupByEmail = (
  queryParams: GetUsersLookupByEmailQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    user: Objs_user;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetUsersLookupByEmail.info(
    queryParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetUsersLookupByEmail.info = (
  queryParams: GetUsersLookupByEmailQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getUsersLookupByEmail.key, queryParams] as QueryKey,
    fun: () => getUsersLookupByEmail(queryParams, configOverride),
  };
};
useGetUsersLookupByEmail.prefetch = (
  client: QueryClient,
  queryParams: GetUsersLookupByEmailQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    user: Objs_user;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetUsersLookupByEmail.info(
    queryParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetUsersProfileGet = (
  queryParams: GetUsersProfileGetQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    profile: Objs_user_profile;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetUsersProfileGet.info(queryParams, configOverride);

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetUsersProfileGet.info = (
  queryParams: GetUsersProfileGetQueryParams,
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getUsersProfileGet.key, queryParams] as QueryKey,
    fun: () => getUsersProfileGet(queryParams, configOverride),
  };
};
useGetUsersProfileGet.prefetch = (
  client: QueryClient,
  queryParams: GetUsersProfileGetQueryParams,
  options?: SwaggerTypescriptUseQueryOptions<{
    ok: Defs_ok_true;
    profile: Objs_user_profile;
  }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetUsersProfileGet.info(queryParams, configOverride);

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetViewsOpen = (
  queryParams: GetViewsOpenQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetViewsOpen.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetViewsOpen.info = (
  queryParams: GetViewsOpenQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getViewsOpen.key, queryParams, headerParams] as QueryKey,
    fun: () => getViewsOpen(queryParams, headerParams, configOverride),
  };
};
useGetViewsOpen.prefetch = (
  client: QueryClient,
  queryParams: GetViewsOpenQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetViewsOpen.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetViewsPublish = (
  queryParams: GetViewsPublishQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetViewsPublish.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetViewsPublish.info = (
  queryParams: GetViewsPublishQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getViewsPublish.key, queryParams, headerParams] as QueryKey,
    fun: () => getViewsPublish(queryParams, headerParams, configOverride),
  };
};
useGetViewsPublish.prefetch = (
  client: QueryClient,
  queryParams: GetViewsPublishQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetViewsPublish.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetViewsPush = (
  queryParams: GetViewsPushQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetViewsPush.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetViewsPush.info = (
  queryParams: GetViewsPushQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getViewsPush.key, queryParams, headerParams] as QueryKey,
    fun: () => getViewsPush(queryParams, headerParams, configOverride),
  };
};
useGetViewsPush.prefetch = (
  client: QueryClient,
  queryParams: GetViewsPushQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetViewsPush.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetViewsUpdate = (
  queryParams?: GetViewsUpdateQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetViewsUpdate.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetViewsUpdate.info = (
  queryParams?: GetViewsUpdateQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getViewsUpdate.key, queryParams, headerParams] as QueryKey,
    fun: () => getViewsUpdate(queryParams, headerParams, configOverride),
  };
};
useGetViewsUpdate.prefetch = (
  client: QueryClient,
  queryParams?: GetViewsUpdateQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetViewsUpdate.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetWorkflowsStepCompleted = (
  queryParams: GetWorkflowsStepCompletedQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetWorkflowsStepCompleted.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetWorkflowsStepCompleted.info = (
  queryParams: GetWorkflowsStepCompletedQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getWorkflowsStepCompleted.key, queryParams, headerParams] as QueryKey,
    fun: () =>
      getWorkflowsStepCompleted(queryParams, headerParams, configOverride),
  };
};
useGetWorkflowsStepCompleted.prefetch = (
  client: QueryClient,
  queryParams: GetWorkflowsStepCompletedQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetWorkflowsStepCompleted.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetWorkflowsStepFailed = (
  queryParams: GetWorkflowsStepFailedQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetWorkflowsStepFailed.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetWorkflowsStepFailed.info = (
  queryParams: GetWorkflowsStepFailedQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getWorkflowsStepFailed.key, queryParams, headerParams] as QueryKey,
    fun: () =>
      getWorkflowsStepFailed(queryParams, headerParams, configOverride),
  };
};
useGetWorkflowsStepFailed.prefetch = (
  client: QueryClient,
  queryParams: GetWorkflowsStepFailedQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetWorkflowsStepFailed.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const useGetWorkflowsUpdateStep = (
  queryParams: GetWorkflowsUpdateStepQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetWorkflowsUpdateStep.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return useQuery({
    queryKey: key,
    queryFn: fun,
    ...options,
  });
};
useGetWorkflowsUpdateStep.info = (
  queryParams: GetWorkflowsUpdateStepQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
) => {
  return {
    key: [getWorkflowsUpdateStep.key, queryParams, headerParams] as QueryKey,
    fun: () =>
      getWorkflowsUpdateStep(queryParams, headerParams, configOverride),
  };
};
useGetWorkflowsUpdateStep.prefetch = (
  client: QueryClient,
  queryParams: GetWorkflowsUpdateStepQueryParams,
  headerParams?: { token: string },
  options?: SwaggerTypescriptUseQueryOptions<{ ok: Defs_ok_true }>,
  configOverride?: AxiosRequestConfig,
) => {
  const { key, fun } = useGetWorkflowsUpdateStep.info(
    queryParams,
    headerParams,
    configOverride,
  );

  return client.getQueryData(key)
    ? Promise.resolve()
    : client.prefetchQuery({
        queryKey: key,
        queryFn: () => fun(),
        ...options,
      });
};
export const usePostAdminAppsApprove = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** The id of the app to approve. */
        app_id?: string;
        /** The id of the request to approve. */
        request_id?: string;
        team_id?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postAdminAppsApprove(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostAdminAppsRestrict = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** The id of the app to restrict. */
        app_id?: string;
        /** The id of the request to restrict. */
        request_id?: string;
        team_id?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postAdminAppsRestrict(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostAdminConversationsArchive = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** The channel to archive. */
        channel_id: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postAdminConversationsArchive(
        requestBody,
        headerParams,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostAdminConversationsConvertToPrivate = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** The channel to convert to private. */
        channel_id: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postAdminConversationsConvertToPrivate(
        requestBody,
        headerParams,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostAdminConversationsCreate = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true; channel_id?: Defs_channel_id },
    {
      requestBody: {
        /** When \`true\`, creates a private channel instead of a public channel */
        is_private: boolean;
        /** Name of the public or private channel to create. */
        name: string;
        /** Description of the public or private channel to create. */
        description?: string;
        /**
         * When \`true\`, the channel will be available org-wide. Note: if the channel is
         * not \`org_wide=true\`, you must specify a \`team_id\` for this channel
         */
        org_wide?: boolean;
        /**
         * The workspace to create the channel in. Note: this argument is required
         * unless you set \`org_wide=true\`.
         */
        team_id?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postAdminConversationsCreate(
        requestBody,
        headerParams,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostAdminConversationsDelete = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** The channel to delete. */
        channel_id: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postAdminConversationsDelete(
        requestBody,
        headerParams,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostAdminConversationsDisconnectShared = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** The channel to be disconnected from some workspaces. */
        channel_id: string;
        /**
         * The team to be removed from the channel. Currently only a single team id can
         * be specified.
         */
        leaving_team_ids?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postAdminConversationsDisconnectShared(
        requestBody,
        headerParams,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostAdminConversationsInvite = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** The channel that the users will be invited to. */
        channel_id: string;
        /** The users to invite. */
        user_ids: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postAdminConversationsInvite(
        requestBody,
        headerParams,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostAdminConversationsRename = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** The channel to rename. */
        channel_id: string;
        name: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postAdminConversationsRename(
        requestBody,
        headerParams,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostAdminConversationsRestrictAccessAddGroup = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** The channel to link this group to. */
        channel_id: string;
        /**
         * The [IDP
         * Group](https://slack.com/help/articles/115001435788-Connect-identity-provider-groups-to-your-Enterprise-Grid-org)
         * ID to be an allowlist for the private channel.
         */
        group_id: string;
        /** Authentication token. Requires scope: \`admin.conversations:write\` */
        token: string;
        /**
         * The workspace where the channel exists. This argument is required for
         * channels only tied to one workspace, and optional for channels that are
         * shared across an organization.
         */
        team_id?: string;
      };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, configOverride } = _o || {};
      return postAdminConversationsRestrictAccessAddGroup(
        requestBody,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostAdminConversationsRestrictAccessRemoveGroup = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** The channel to remove the linked group from. */
        channel_id: string;
        /**
         * The [IDP
         * Group](https://slack.com/help/articles/115001435788-Connect-identity-provider-groups-to-your-Enterprise-Grid-org)
         * ID to remove from the private channel.
         */
        group_id: string;
        /**
         * The workspace where the channel exists. This argument is required for
         * channels only tied to one workspace, and optional for channels that are
         * shared across an organization.
         */
        team_id: string;
        /** Authentication token. Requires scope: \`admin.conversations:write\` */
        token: string;
      };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, configOverride } = _o || {};
      return postAdminConversationsRestrictAccessRemoveGroup(
        requestBody,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostAdminConversationsSetConversationPrefs = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** The channel to set the prefs for */
        channel_id: string;
        /** The prefs for this channel in a stringified JSON format. */
        prefs: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postAdminConversationsSetConversationPrefs(
        requestBody,
        headerParams,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostAdminConversationsSetTeams = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** The encoded \`channel_id\` to add or remove to workspaces. */
        channel_id: string;
        /** True if channel has to be converted to an org channel */
        org_channel?: boolean;
        /**
         * A comma-separated list of workspaces to which the channel should be shared.
         * Not required if the channel is being shared org-wide.
         */
        target_team_ids?: string;
        /**
         * The workspace to which the channel belongs. Omit this argument if the channel
         * is a cross-workspace shared channel.
         */
        team_id?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postAdminConversationsSetTeams(
        requestBody,
        headerParams,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostAdminConversationsUnarchive = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** The channel to unarchive. */
        channel_id: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postAdminConversationsUnarchive(
        requestBody,
        headerParams,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostAdminEmojiAdd = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /**
         * The name of the emoji to be removed. Colons (\`:myemoji:\`) around the value
         * are not required, although they may be included.
         */
        name: string;
        /** Authentication token. Requires scope: \`admin.teams:write\` */
        token: string;
        /**
         * The URL of a file to use as an image for the emoji. Square images under 128KB
         * and with transparent backgrounds work best.
         */
        url: string;
      };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, configOverride } = _o || {};
      return postAdminEmojiAdd(requestBody, configOverride);
    },
    ...options,
  });
};
export const usePostAdminEmojiAddAlias = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** The alias of the emoji. */
        alias_for: string;
        /**
         * The name of the emoji to be aliased. Colons (\`:myemoji:\`) around the value
         * are not required, although they may be included.
         */
        name: string;
        /** Authentication token. Requires scope: \`admin.teams:write\` */
        token: string;
      };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, configOverride } = _o || {};
      return postAdminEmojiAddAlias(requestBody, configOverride);
    },
    ...options,
  });
};
export const usePostAdminEmojiRemove = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /**
         * The name of the emoji to be removed. Colons (\`:myemoji:\`) around the value
         * are not required, although they may be included.
         */
        name: string;
        /** Authentication token. Requires scope: \`admin.teams:write\` */
        token: string;
      };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, configOverride } = _o || {};
      return postAdminEmojiRemove(requestBody, configOverride);
    },
    ...options,
  });
};
export const usePostAdminEmojiRename = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /**
         * The name of the emoji to be renamed. Colons (\`:myemoji:\`) around the value
         * are not required, although they may be included.
         */
        name: string;
        /** The new name of the emoji. */
        new_name: string;
        /** Authentication token. Requires scope: \`admin.teams:write\` */
        token: string;
      };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, configOverride } = _o || {};
      return postAdminEmojiRename(requestBody, configOverride);
    },
    ...options,
  });
};
export const usePostAdminInviteRequestsApprove = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: RequestBodyAdmin_inviteRequests_approve;
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postAdminInviteRequestsApprove(
        requestBody,
        headerParams,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostAdminInviteRequestsDeny = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: RequestBodyAdmin_inviteRequests_approve;
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postAdminInviteRequestsDeny(
        requestBody,
        headerParams,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostAdminTeamsCreate = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** Team domain (for example, slacksoftballteam). */
        team_domain: string;
        /** Team name (for example, Slack Softball Team). */
        team_name: string;
        /** Description for the team. */
        team_description?: string;
        /**
         * Who can join the team. A team's discoverability can be \`open\`, \`closed\`,
         * \`invite_only\`, or \`unlisted\`.
         */
        team_discoverability?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postAdminTeamsCreate(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostAdminTeamsSettingsSetDefaultChannels = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** An array of channel IDs. */
        channel_ids: string;
        /** ID for the workspace to set the default channel for. */
        team_id: string;
        /** Authentication token. Requires scope: \`admin.teams:write\` */
        token: string;
      };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, configOverride } = _o || {};
      return postAdminTeamsSettingsSetDefaultChannels(
        requestBody,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostAdminTeamsSettingsSetDescription = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** The new description for the workspace. */
        description: string;
        /** ID for the workspace to set the description for. */
        team_id: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postAdminTeamsSettingsSetDescription(
        requestBody,
        headerParams,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostAdminTeamsSettingsSetDiscoverability = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /**
         * This workspace's discovery setting. It must be set to one of \`open\`,
         * \`invite_only\`, \`closed\`, or \`unlisted\`.
         */
        discoverability: string;
        /** The ID of the workspace to set discoverability on. */
        team_id: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postAdminTeamsSettingsSetDiscoverability(
        requestBody,
        headerParams,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostAdminTeamsSettingsSetIcon = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** Image URL for the icon */
        image_url: string;
        /** ID for the workspace to set the icon for. */
        team_id: string;
        /** Authentication token. Requires scope: \`admin.teams:write\` */
        token: string;
      };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, configOverride } = _o || {};
      return postAdminTeamsSettingsSetIcon(requestBody, configOverride);
    },
    ...options,
  });
};
export const usePostAdminTeamsSettingsSetName = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** The new name of the workspace. */
        name: string;
        /** ID for the workspace to set the name for. */
        team_id: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postAdminTeamsSettingsSetName(
        requestBody,
        headerParams,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostAdminUsergroupsAddChannels = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** Comma separated string of channel IDs. */
        channel_ids: string;
        /** ID of the IDP group to add default channels for. */
        usergroup_id: string;
        /** The workspace to add default channels in. */
        team_id?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postAdminUsergroupsAddChannels(
        requestBody,
        headerParams,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostAdminUsergroupsAddTeams = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /**
         * A comma separated list of encoded team (workspace) IDs. Each workspace _MUST_
         * belong to the organization associated with the token.
         */
        team_ids: string;
        /** An encoded usergroup (IDP Group) ID. */
        usergroup_id: string;
        /**
         * When \`true\`, this method automatically creates new workspace accounts for the
         * IDP group members.
         */
        auto_provision?: boolean;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postAdminUsergroupsAddTeams(
        requestBody,
        headerParams,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostAdminUsergroupsRemoveChannels = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** Comma-separated string of channel IDs */
        channel_ids: string;
        /** ID of the IDP Group */
        usergroup_id: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postAdminUsergroupsRemoveChannels(
        requestBody,
        headerParams,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostAdminUsersAssign = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** The ID (\`T1234\`) of the workspace. */
        team_id: string;
        /** The ID of the user to add to the workspace. */
        user_id: string;
        /** Comma separated values of channel IDs to add user in the new workspace. */
        channel_ids?: string;
        /** True if user should be added to the workspace as a guest. */
        is_restricted?: boolean;
        /** True if user should be added to the workspace as a single-channel guest. */
        is_ultra_restricted?: boolean;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postAdminUsersAssign(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostAdminUsersInvite = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /**
         * A comma-separated list of \`channel_id\`s for this user to join. At least one
         * channel is required.
         */
        channel_ids: string;
        /** The email address of the person to invite. */
        email: string;
        /** The ID (\`T1234\`) of the workspace. */
        team_id: string;
        /** An optional message to send to the user in the invite email. */
        custom_message?: string;
        /**
         * Timestamp when guest account should be disabled. Only include this timestamp
         * if you are inviting a guest user and you want their account to expire on a
         * certain date.
         */
        guest_expiration_ts?: string;
        /** Is this user a multi-channel guest user? (default: false) */
        is_restricted?: boolean;
        /** Is this user a single channel guest user? (default: false) */
        is_ultra_restricted?: boolean;
        /** Full name of the user. */
        real_name?: string;
        /**
         * Allow this invite to be resent in the future if a user has not signed up yet.
         * (default: false)
         */
        resend?: boolean;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postAdminUsersInvite(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostAdminUsersRemove = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** The ID (\`T1234\`) of the workspace. */
        team_id: string;
        /** The ID of the user to remove. */
        user_id: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postAdminUsersRemove(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostAdminUsersSessionInvalidate = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        session_id: number;
        /** ID of the team that the session belongs to */
        team_id: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postAdminUsersSessionInvalidate(
        requestBody,
        headerParams,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostAdminUsersSessionReset = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** The ID of the user to wipe sessions for */
        user_id: string;
        /** Only expire mobile sessions (default: false) */
        mobile_only?: boolean;
        /** Only expire web sessions (default: false) */
        web_only?: boolean;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postAdminUsersSessionReset(
        requestBody,
        headerParams,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostAdminUsersSetAdmin = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** The ID (\`T1234\`) of the workspace. */
        team_id: string;
        /** The ID of the user to designate as an admin. */
        user_id: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postAdminUsersSetAdmin(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostAdminUsersSetExpiration = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** Timestamp when guest account should be disabled. */
        expiration_ts: number;
        /** The ID (\`T1234\`) of the workspace. */
        team_id: string;
        /** The ID of the user to set an expiration for. */
        user_id: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postAdminUsersSetExpiration(
        requestBody,
        headerParams,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostAdminUsersSetOwner = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** The ID (\`T1234\`) of the workspace. */
        team_id: string;
        /** Id of the user to promote to owner. */
        user_id: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postAdminUsersSetOwner(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostAdminUsersSetRegular = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** The ID (\`T1234\`) of the workspace. */
        team_id: string;
        /** The ID of the user to designate as a regular user. */
        user_id: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postAdminUsersSetRegular(
        requestBody,
        headerParams,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostCallsAdd = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /**
         * An ID supplied by the 3rd-party Call provider. It must be unique across all
         * Calls from that service.
         */
        external_unique_id: string;
        /** The URL required for a client to join the Call. */
        join_url: string;
        /**
         * The valid Slack user ID of the user who created this Call. When this method
         * is called with a user token, the \`created_by\` field is optional and defaults
         * to the authed user of the token. Otherwise, the field is required.
         */
        created_by?: string;
        /** Call start time in UTC UNIX timestamp format */
        date_start?: number;
        /**
         * When supplied, available Slack clients will attempt to directly launch the
         * 3rd-party Call with this URL.
         */
        desktop_app_join_url?: string;
        /**
         * An optional, human-readable ID supplied by the 3rd-party Call provider. If
         * supplied, this ID will be displayed in the Call object.
         */
        external_display_id?: string;
        /** The name of the Call. */
        title?: string;
        /**
         * The list of users to register as participants in the Call. [Read more on how
         * to specify users here](/apis/calls#users).
         */
        users?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postCallsAdd(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostCallsEnd = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /**
         * \`id\` returned when registering the call using the
         * [\`calls.add\`](/methods/calls.add) method.
         */
        id: string;
        /** Call duration in seconds */
        duration?: number;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postCallsEnd(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostCallsParticipantsAdd = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** \`id\` returned by the [\`calls.add\`](/methods/calls.add) method. */
        id: string;
        /**
         * The list of users to add as participants in the Call. [Read more on how to
         * specify users here](/apis/calls#users).
         */
        users: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postCallsParticipantsAdd(
        requestBody,
        headerParams,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostCallsParticipantsRemove = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** \`id\` returned by the [\`calls.add\`](/methods/calls.add) method. */
        id: string;
        /**
         * The list of users to remove as participants in the Call. [Read more on how to
         * specify users here](/apis/calls#users).
         */
        users: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postCallsParticipantsRemove(
        requestBody,
        headerParams,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostCallsUpdate = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** \`id\` returned by the [\`calls.add\`](/methods/calls.add) method. */
        id: string;
        /**
         * When supplied, available Slack clients will attempt to directly launch the
         * 3rd-party Call with this URL.
         */
        desktop_app_join_url?: string;
        /** The URL required for a client to join the Call. */
        join_url?: string;
        /** The name of the Call. */
        title?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postCallsUpdate(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostChatDelete = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { channel: Defs_channel; ok: Defs_ok_true; ts: Defs_ts },
    {
      requestBody: {
        /**
         * Pass true to delete the message as the authed user with \`chat:write:user\`
         * scope. [Bot users](/bot-users) in this context are considered authed users.
         * If unused or false, the message will be deleted with \`chat:write:bot\` scope.
         */
        as_user?: boolean;
        /** Channel containing the message to be deleted. */
        channel?: string;
        /** Timestamp of the message to be deleted. */
        ts?: number;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postChatDelete(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostChatDeleteScheduledMessage = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** The channel the scheduled_message is posting to */
        channel: string;
        /** \`scheduled_message_id\` returned from call to chat.scheduleMessage */
        scheduled_message_id: string;
        /**
         * Pass true to delete the message as the authed user with \`chat:write:user\`
         * scope. [Bot users](/bot-users) in this context are considered authed users.
         * If unused or false, the message will be deleted with \`chat:write:bot\` scope.
         */
        as_user?: boolean;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postChatDeleteScheduledMessage(
        requestBody,
        headerParams,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostChatMeMessage = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true; channel?: Defs_channel; ts?: Defs_ts },
    {
      requestBody: {
        /**
         * Channel to send message to. Can be a public channel, private group or IM
         * channel. Can be an encoded ID, or a name.
         */
        channel?: string;
        /** Text of the message to send. */
        text?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postChatMeMessage(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostChatPostEphemeral = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { message_ts: Defs_ts; ok: Defs_ok_true },
    {
      requestBody: {
        /**
         * Channel, private group, or IM channel to send message to. Can be an encoded
         * ID, or a name.
         */
        channel: string;
        /**
         * \`id\` of the user who will receive the ephemeral message. The user should be
         * in the channel specified by the \`channel\` argument.
         */
        user: string;
        /**
         * Pass true to post the message as the authed user. Defaults to true if the
         * chat:write:bot scope is not included. Otherwise, defaults to false.
         */
        as_user?: boolean;
        /**
         * A JSON-based array of structured attachments, presented as a URL-encoded
         * string.
         */
        attachments?: string;
        /** A JSON-based array of structured blocks, presented as a URL-encoded string. */
        blocks?: string;
        /**
         * Emoji to use as the icon for this message. Overrides \`icon_url\`. Must be used
         * in conjunction with \`as_user\` set to \`false\`, otherwise ignored. See
         * [authorship](#authorship) below.
         */
        icon_emoji?: string;
        /**
         * URL to an image to use as the icon for this message. Must be used in
         * conjunction with \`as_user\` set to false, otherwise ignored. See
         * [authorship](#authorship) below.
         */
        icon_url?: string;
        /** Find and link channel names and usernames. */
        link_names?: boolean;
        /**
         * Change how messages are treated. Defaults to \`none\`. See
         * [below](#formatting).
         */
        parse?: string;
        /**
         * How this field works and whether it is required depends on other fields you
         * use in your API call. [See below](#text_usage) for more detail.
         */
        text?: string;
        /**
         * Provide another message's \`ts\` value to post this message in a thread. Avoid
         * using a reply's \`ts\` value; use its parent's value instead. Ephemeral
         * messages in threads are only shown if there is already an active thread.
         */
        thread_ts?: string;
        /**
         * Set your bot's user name. Must be used in conjunction with \`as_user\` set to
         * false, otherwise ignored. See [authorship](#authorship) below.
         */
        username?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postChatPostEphemeral(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostChatPostMessage = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    {
      channel: Defs_channel;
      message: Objs_message;
      ok: Defs_ok_true;
      ts: Defs_ts;
    },
    {
      requestBody: {
        /**
         * Channel, private group, or IM channel to send message to. Can be an encoded
         * ID, or a name. See [below](#channels) for more details.
         */
        channel: string;
        /**
         * Pass true to post the message as the authed user, instead of as a bot.
         * Defaults to false. See [authorship](#authorship) below.
         */
        as_user?: string;
        /**
         * A JSON-based array of structured attachments, presented as a URL-encoded
         * string.
         */
        attachments?: string;
        /** A JSON-based array of structured blocks, presented as a URL-encoded string. */
        blocks?: string;
        /**
         * Emoji to use as the icon for this message. Overrides \`icon_url\`. Must be used
         * in conjunction with \`as_user\` set to \`false\`, otherwise ignored. See
         * [authorship](#authorship) below.
         */
        icon_emoji?: string;
        /**
         * URL to an image to use as the icon for this message. Must be used in
         * conjunction with \`as_user\` set to false, otherwise ignored. See
         * [authorship](#authorship) below.
         */
        icon_url?: string;
        /** Find and link channel names and usernames. */
        link_names?: boolean;
        /** Disable Slack markup parsing by setting to \`false\`. Enabled by default. */
        mrkdwn?: boolean;
        /**
         * Change how messages are treated. Defaults to \`none\`. See
         * [below](#formatting).
         */
        parse?: string;
        /**
         * Used in conjunction with \`thread_ts\` and indicates whether reply should be
         * made visible to everyone in the channel or conversation. Defaults to
         * \`false\`.
         */
        reply_broadcast?: boolean;
        /**
         * How this field works and whether it is required depends on other fields you
         * use in your API call. [See below](#text_usage) for more detail.
         */
        text?: string;
        /**
         * Provide another message's \`ts\` value to make this message a reply. Avoid
         * using a reply's \`ts\` value; use its parent instead.
         */
        thread_ts?: string;
        /** Pass true to enable unfurling of primarily text-based content. */
        unfurl_links?: boolean;
        /** Pass false to disable unfurling of media content. */
        unfurl_media?: boolean;
        /**
         * Set your bot's user name. Must be used in conjunction with \`as_user\` set to
         * false, otherwise ignored. See [authorship](#authorship) below.
         */
        username?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postChatPostMessage(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostChatScheduleMessage = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    {
      channel: Defs_channel;
      message: {
        bot_id: Defs_bot_id;
        team: Defs_team;
        text: string;
        type: string;
        user: Defs_user_id;
        bot_profile?: Objs_bot_profile;
        username?: string;
      };
      ok: Defs_ok_true;
      /** - Pattern: ^\\\\d{10}$ */
      post_at: number;
      /**
       * Scheduled Message ID
       *
       * - Pattern: ^[Q][A-Z0-9]{8,}$
       */
      scheduled_message_id: string;
    },
    {
      requestBody: {
        /**
         * Pass true to post the message as the authed user, instead of as a bot.
         * Defaults to false. See [chat.postMessage](chat.postMessage#authorship).
         */
        as_user?: boolean;
        /**
         * A JSON-based array of structured attachments, presented as a URL-encoded
         * string.
         */
        attachments?: string;
        /** A JSON-based array of structured blocks, presented as a URL-encoded string. */
        blocks?: string;
        /**
         * Channel, private group, or DM channel to send message to. Can be an encoded
         * ID, or a name. See [below](#channels) for more details.
         */
        channel?: string;
        /** Find and link channel names and usernames. */
        link_names?: boolean;
        /**
         * Change how messages are treated. Defaults to \`none\`. See
         * [chat.postMessage](chat.postMessage#formatting).
         */
        parse?: string;
        /** Unix EPOCH timestamp of time in future to send the message. */
        post_at?: string;
        /**
         * Used in conjunction with \`thread_ts\` and indicates whether reply should be
         * made visible to everyone in the channel or conversation. Defaults to
         * \`false\`.
         */
        reply_broadcast?: boolean;
        /**
         * How this field works and whether it is required depends on other fields you
         * use in your API call. [See below](#text_usage) for more detail.
         */
        text?: string;
        /**
         * Provide another message's \`ts\` value to make this message a reply. Avoid
         * using a reply's \`ts\` value; use its parent instead.
         */
        thread_ts?: number;
        /** Pass true to enable unfurling of primarily text-based content. */
        unfurl_links?: boolean;
        /** Pass false to disable unfurling of media content. */
        unfurl_media?: boolean;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postChatScheduleMessage(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostChatUnfurl = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** Channel ID of the message */
        channel: string;
        /** Timestamp of the message to add unfurl behavior to. */
        ts: string;
        /**
         * URL-encoded JSON map with keys set to URLs featured in the the message,
         * pointing to their unfurl blocks or message attachments.
         */
        unfurls?: string;
        /**
         * Provide a simply-formatted string to send as an ephemeral message to the user
         * as invitation to authenticate further and enable full unfurling behavior
         */
        user_auth_message?: string;
        /**
         * Set to \`true\` or \`1\` to indicate the user must install your Slack app to
         * trigger unfurls for this domain
         */
        user_auth_required?: boolean;
        /**
         * Send users to this custom URL where they will complete authentication in your
         * app to fully trigger unfurling. Value should be properly URL-encoded.
         */
        user_auth_url?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postChatUnfurl(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostChatUpdate = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    {
      channel: string;
      /** Message object */
      message: {
        text: string;
        attachments?: { [x in string | number]: any }[];
        blocks?: { [x in string | number]: any };
      };
      ok: Defs_ok_true;
      text: string;
      ts: string;
    },
    {
      requestBody: {
        /** Channel containing the message to be updated. */
        channel: string;
        /** Timestamp of the message to be updated. */
        ts: string;
        /**
         * Pass true to update the message as the authed user. [Bot users](/bot-users)
         * in this context are considered authed users.
         */
        as_user?: string;
        /**
         * A JSON-based array of structured attachments, presented as a URL-encoded
         * string. This field is required when not presenting \`text\`. If you don't
         * include this field, the message's previous \`attachments\` will be retained. To
         * remove previous \`attachments\`, include an empty array for this field.
         */
        attachments?: string;
        /**
         * A JSON-based array of [structured blocks](/block-kit/building), presented as
         * a URL-encoded string. If you don't include this field, the message's previous
         * \`blocks\` will be retained. To remove previous \`blocks\`, include an empty
         * array for this field.
         */
        blocks?: string;
        /**
         * Find and link channel names and usernames. Defaults to \`none\`. If you do not
         * specify a value for this field, the original value set for the message will
         * be overwritten with the default, \`none\`.
         */
        link_names?: string;
        /**
         * Change how messages are treated. Defaults to \`client\`, unlike
         * \`chat.postMessage\`. Accepts either \`none\` or \`full\`. If you do not specify a
         * value for this field, the original value set for the message will be
         * overwritten with the default, \`client\`.
         */
        parse?: string;
        /**
         * New text for the message, using the [default formatting
         * rules](/reference/surfaces/formatting). It's not required when presenting
         * \`blocks\` or \`attachments\`.
         */
        text?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postChatUpdate(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostConversationsArchive = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** ID of conversation to archive */
        channel?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postConversationsArchive(
        requestBody,
        headerParams,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostConversationsClose = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true; already_closed?: boolean; no_op?: boolean },
    {
      requestBody: {
        /** Conversation to close. */
        channel?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postConversationsClose(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostConversationsCreate = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { channel: Objs_conversation; ok: Defs_ok_true },
    {
      requestBody: {
        /** Create a private channel instead of a public one */
        is_private?: boolean;
        /** Name of the public or private channel to create */
        name?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postConversationsCreate(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostConversationsInvite = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { channel: Objs_conversation; ok: Defs_ok_true },
    {
      requestBody: {
        /** The ID of the public or private channel to invite user(s) to. */
        channel?: string;
        /** A comma separated list of user IDs. Up to 1000 users may be listed. */
        users?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postConversationsInvite(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostConversationsJoin = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    {
      channel: Objs_conversation;
      ok: Defs_ok_true;
      /** Response metadata */
      response_metadata?: { warnings?: string[] };
      warning?: string;
    },
    {
      requestBody: {
        /** ID of conversation to join */
        channel?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postConversationsJoin(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostConversationsKick = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** ID of conversation to remove user from. */
        channel?: string;
        /** User ID to be removed. */
        user?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postConversationsKick(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostConversationsLeave = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true; not_in_channel?: true },
    {
      requestBody: {
        /** Conversation to leave */
        channel?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postConversationsLeave(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostConversationsMark = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** Channel or conversation to set the read cursor for. */
        channel?: string;
        /**
         * Unique identifier of message you want marked as most recently seen in this
         * conversation.
         */
        ts?: number;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postConversationsMark(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostConversationsOpen = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    {
      channel: (
        | Objs_conversation
        | {
            id: Defs_dm_id;
            created?: string;
            is_im?: boolean;
            is_open?: boolean;
            last_read?: Defs_ts;
            latest?: Objs_message;
            unread_count?: number;
            unread_count_display?: number;
            user?: Defs_user_id;
          }
      )[];
      ok: Defs_ok_true;
      already_open?: boolean;
      no_op?: boolean;
    },
    {
      requestBody: {
        /**
         * Resume a conversation by supplying an \`im\` or \`mpim\`'s ID. Or provide the
         * \`users\` field instead.
         */
        channel?: string;
        /** Boolean, indicates you want the full IM channel definition in the response. */
        return_im?: boolean;
        /**
         * Comma separated lists of users. If only one user is included, this creates a
         * 1:1 DM. The ordering of the users is preserved whenever a multi-person direct
         * message is returned. Supply a \`channel\` when not supplying \`users\`.
         */
        users?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postConversationsOpen(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostConversationsRename = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { channel: Objs_conversation; ok: Defs_ok_true },
    {
      requestBody: {
        /** ID of conversation to rename */
        channel?: string;
        /** New name for conversation. */
        name?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postConversationsRename(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostConversationsSetPurpose = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { channel: Objs_conversation; ok: Defs_ok_true },
    {
      requestBody: {
        /** Conversation to set the purpose of */
        channel?: string;
        /** A new, specialer purpose */
        purpose?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postConversationsSetPurpose(
        requestBody,
        headerParams,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostConversationsSetTopic = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { channel: Objs_conversation; ok: Defs_ok_true },
    {
      requestBody: {
        /** Conversation to set the topic of */
        channel?: string;
        /** The new topic string. Does not support formatting or linkification. */
        topic?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postConversationsSetTopic(
        requestBody,
        headerParams,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostConversationsUnarchive = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** ID of conversation to unarchive */
        channel?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postConversationsUnarchive(
        requestBody,
        headerParams,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostDndEndDnd = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    { headerParams?: { token: string } },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { headerParams, configOverride } = _o || {};
      return postDndEndDnd(headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostDndEndSnooze = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    {
      dnd_enabled: boolean;
      next_dnd_end_ts: number;
      next_dnd_start_ts: number;
      ok: Defs_ok_true;
      snooze_enabled: boolean;
    },
    { headerParams?: { token: string } },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { headerParams, configOverride } = _o || {};
      return postDndEndSnooze(headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostDndSetSnooze = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    {
      ok: Defs_ok_true;
      snooze_enabled: boolean;
      snooze_endtime: number;
      snooze_remaining: number;
    },
    {
      requestBody: {
        /** Number of minutes, from now, to snooze until. */
        num_minutes: string;
        /** Authentication token. Requires scope: \`dnd:write\` */
        token: string;
      };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, configOverride } = _o || {};
      return postDndSetSnooze(requestBody, configOverride);
    },
    ...options,
  });
};
export const usePostFilesCommentsDelete = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** File to delete a comment from. */
        file?: string;
        /** The comment to delete. */
        id?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postFilesCommentsDelete(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostFilesDelete = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** ID of file to delete. */
        file?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postFilesDelete(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostFilesRemoteAdd = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** Creator defined GUID for the file. */
        external_id?: string;
        /** URL of the remote file. */
        external_url?: string;
        /** Type of file */
        filetype?: string;
        /**
         * A text file (txt, pdf, doc, etc.) containing textual search terms that are
         * used to improve discovery of the remote file.
         */
        indexable_file_contents?: string;
        /** Preview of the document via \`multipart/form-data\`. */
        preview_image?: string;
        /** Title of the file being shared. */
        title?: string;
        /** Authentication token. Requires scope: \`remote_files:write\` */
        token?: string;
      };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, configOverride } = _o || {};
      return postFilesRemoteAdd(requestBody, configOverride);
    },
    ...options,
  });
};
export const usePostFilesRemoteRemove = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** Creator defined GUID for the file. */
        external_id?: string;
        /** Specify a file by providing its ID. */
        file?: string;
        /** Authentication token. Requires scope: \`remote_files:write\` */
        token?: string;
      };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, configOverride } = _o || {};
      return postFilesRemoteRemove(requestBody, configOverride);
    },
    ...options,
  });
};
export const usePostFilesRemoteUpdate = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** Creator defined GUID for the file. */
        external_id?: string;
        /** URL of the remote file. */
        external_url?: string;
        /** Specify a file by providing its ID. */
        file?: string;
        /** Type of file */
        filetype?: string;
        /**
         * File containing contents that can be used to improve searchability for the
         * remote file.
         */
        indexable_file_contents?: string;
        /** Preview of the document via \`multipart/form-data\`. */
        preview_image?: string;
        /** Title of the file being shared. */
        title?: string;
        /** Authentication token. Requires scope: \`remote_files:write\` */
        token?: string;
      };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, configOverride } = _o || {};
      return postFilesRemoteUpdate(requestBody, configOverride);
    },
    ...options,
  });
};
export const usePostFilesRevokePublicURL = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { file: Objs_file; ok: Defs_ok_true },
    {
      requestBody: {
        /** File to revoke */
        file?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postFilesRevokePublicURL(
        requestBody,
        headerParams,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostFilesSharedPublicURL = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { file: Objs_file; ok: Defs_ok_true },
    {
      requestBody: {
        /** File to share */
        file?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postFilesSharedPublicURL(
        requestBody,
        headerParams,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostFilesUpload = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { file: Objs_file; ok: Defs_ok_true },
    {
      requestBody: {
        /** Comma-separated list of channel names or IDs where the file will be shared. */
        channels?: string;
        /**
         * File contents via a POST variable. If omitting this parameter, you must
         * provide a \`file\`.
         */
        content?: string;
        /**
         * File contents via \`multipart/form-data\`. If omitting this parameter, you must
         * submit \`content\`.
         */
        file?: string;
        /** Filename of file. */
        filename?: string;
        /** A [file type](/types/file#file_types) identifier. */
        filetype?: string;
        /** The message text introducing the file in specified \`channels\`. */
        initial_comment?: string;
        /**
         * Provide another message's \`ts\` value to upload this file as a reply. Never
         * use a reply's \`ts\` value; use its parent instead.
         */
        thread_ts?: number;
        /** Title of file. */
        title?: string;
        /** Authentication token. Requires scope: \`files:write:user\` */
        token?: string;
      };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, configOverride } = _o || {};
      return postFilesUpload(requestBody, configOverride);
    },
    ...options,
  });
};
export const usePostPinsAdd = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** Channel to pin the item in. */
        channel: string;
        /** Timestamp of the message to pin. */
        timestamp?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postPinsAdd(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostPinsRemove = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** Channel where the item is pinned to. */
        channel: string;
        /** Timestamp of the message to un-pin. */
        timestamp?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postPinsRemove(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostReactionsAdd = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** Channel where the message to add reaction to was posted. */
        channel: string;
        /** Reaction (emoji) name. */
        name: string;
        /** Timestamp of the message to add reaction to. */
        timestamp: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postReactionsAdd(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostReactionsRemove = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** Reaction (emoji) name. */
        name: string;
        /** Channel where the message to remove reaction from was posted. */
        channel?: string;
        /** File to remove reaction from. */
        file?: string;
        /** File comment to remove reaction from. */
        file_comment?: string;
        /** Timestamp of the message to remove reaction from. */
        timestamp?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postReactionsRemove(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostRemindersAdd = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true; reminder: Objs_reminder },
    {
      requestBody: {
        /** The content of the reminder */
        text: string;
        /**
         * When this reminder should happen: the Unix timestamp (up to five years from
         * now), the number of seconds until the reminder (if within 24 hours), or a
         * natural language description (Ex. \\"in 15 minutes,\\" or \\"every Thursday\\")
         */
        time: string;
        /**
         * The user who will receive the reminder. If no user is specified, the reminder
         * will go to user who created it.
         */
        user?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postRemindersAdd(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostRemindersComplete = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** The ID of the reminder to be marked as complete */
        reminder?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postRemindersComplete(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostRemindersDelete = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** The ID of the reminder */
        reminder?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postRemindersDelete(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostStarsAdd = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /**
         * Channel to add star to, or channel where the message to add star to was
         * posted (used with \`timestamp\`).
         */
        channel?: string;
        /** File to add star to. */
        file?: string;
        /** File comment to add star to. */
        file_comment?: string;
        /** Timestamp of the message to add star to. */
        timestamp?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postStarsAdd(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostStarsRemove = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /**
         * Channel to remove star from, or channel where the message to remove star from
         * was posted (used with \`timestamp\`).
         */
        channel?: string;
        /** File to remove star from. */
        file?: string;
        /** File comment to remove star from. */
        file_comment?: string;
        /** Timestamp of the message to remove star from. */
        timestamp?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postStarsRemove(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostUsergroupsCreate = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true; usergroup: Objs_subteam },
    {
      requestBody: {
        /** A name for the User Group. Must be unique among User Groups. */
        name: string;
        /**
         * A comma separated string of encoded channel IDs for which the User Group uses
         * as a default.
         */
        channels?: string;
        /** A short description of the User Group. */
        description?: string;
        /** A mention handle. Must be unique among channels, users and User Groups. */
        handle?: string;
        /** Include the number of users in each User Group. */
        include_count?: boolean;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postUsergroupsCreate(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostUsergroupsDisable = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true; usergroup: Objs_subteam },
    {
      requestBody: {
        /** The encoded ID of the User Group to disable. */
        usergroup: string;
        /** Include the number of users in the User Group. */
        include_count?: boolean;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postUsergroupsDisable(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostUsergroupsEnable = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true; usergroup: Objs_subteam },
    {
      requestBody: {
        /** The encoded ID of the User Group to enable. */
        usergroup: string;
        /** Include the number of users in the User Group. */
        include_count?: boolean;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postUsergroupsEnable(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostUsergroupsUpdate = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true; usergroup: Objs_subteam },
    {
      requestBody: {
        /** The encoded ID of the User Group to update. */
        usergroup: string;
        /**
         * A comma separated string of encoded channel IDs for which the User Group uses
         * as a default.
         */
        channels?: string;
        /** A short description of the User Group. */
        description?: string;
        /** A mention handle. Must be unique among channels, users and User Groups. */
        handle?: string;
        /** Include the number of users in the User Group. */
        include_count?: boolean;
        /** A name for the User Group. Must be unique among User Groups. */
        name?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postUsergroupsUpdate(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostUsergroupsUsersUpdate = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true; usergroup: Objs_subteam },
    {
      requestBody: {
        /** The encoded ID of the User Group to update. */
        usergroup: string;
        /**
         * A comma separated string of encoded user IDs that represent the entire list
         * of users for the User Group.
         */
        users: string;
        /** Include the number of users in the User Group. */
        include_count?: boolean;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postUsergroupsUsersUpdate(
        requestBody,
        headerParams,
        configOverride,
      );
    },
    ...options,
  });
};
export const usePostUsersDeletePhoto = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** Authentication token. Requires scope: \`users.profile:write\` */
        token: string;
      };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, configOverride } = _o || {};
      return postUsersDeletePhoto(requestBody, configOverride);
    },
    ...options,
  });
};
export const usePostUsersProfileSet = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    {
      ok: Defs_ok_true;
      profile: Objs_user_profile;
      username: string;
      /** - Format: email */
      email_pending?: string;
    },
    {
      requestBody: {
        /** Name of a single key to set. Usable only if \`profile\` is not passed. */
        name?: string;
        /**
         * Collection of key:value pairs presented as a URL-encoded JSON hash. At most
         * 50 fields may be set. Each field name is limited to 255 characters.
         */
        profile?: string;
        /**
         * ID of user to change. This argument may only be specified by team admins on
         * paid teams.
         */
        user?: string;
        /** Value to set a single key to. Usable only if \`profile\` is not passed. */
        value?: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postUsersProfileSet(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostUsersSetActive = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    { headerParams?: { token: string } },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { headerParams, configOverride } = _o || {};
      return postUsersSetActive(headerParams, configOverride);
    },
    ...options,
  });
};
export const usePostUsersSetPhoto = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    {
      ok: Defs_ok_true;
      profile: {
        /** - Pattern: ^[0-9a-f]{12}$ */
        avatar_hash: string;
        /** - Format: uri */
        image_1024: string;
        /** - Format: uri */
        image_192: string;
        /** - Format: uri */
        image_24: string;
        /** - Format: uri */
        image_32: string;
        /** - Format: uri */
        image_48: string;
        /** - Format: uri */
        image_512: string;
        /** - Format: uri */
        image_72: string;
        /** - Format: uri */
        image_original: string;
      };
    },
    {
      requestBody: {
        /** Authentication token. Requires scope: \`users.profile:write\` */
        token: string;
        /** Width/height of crop box (always square) */
        crop_w?: string;
        /** X coordinate of top-left corner of crop box */
        crop_x?: string;
        /** Y coordinate of top-left corner of crop box */
        crop_y?: string;
        /** File contents via \`multipart/form-data\`. */
        image?: string;
      };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, configOverride } = _o || {};
      return postUsersSetPhoto(requestBody, configOverride);
    },
    ...options,
  });
};
export const usePostUsersSetPresence = <TExtra,>(
  options?: SwaggerTypescriptUseMutationOptions<
    { ok: Defs_ok_true },
    {
      requestBody: {
        /** Either \`auto\` or \`away\` */
        presence: string;
      };
      headerParams?: { token: string };
    },
    TExtra
  >,
) => {
  return useMutation({
    mutationFn: (_o) => {
      const { requestBody, headerParams, configOverride } = _o || {};
      return postUsersSetPresence(requestBody, headerParams, configOverride);
    },
    ...options,
  });
};
",
  "hooksConfig.ts": "//@ts-nocheck
/**
 * AUTO_GENERATED Do not change this file directly, use config.ts file instead
 *
 * @version 6
 */

import type { SwaggerResponse } from \\"./config\\";

type GetDataType<
  T extends Array<SwaggerResponse<any>>,
  K extends string = \\"data\\" | \\"list\\",
> = T extends Array<SwaggerResponse<infer D>>
  ? D extends {
      [P in K]?: infer R1;
    }
    ? R1
    : D extends Array<any>
    ? D
    : never
  : never;

const paginationFlattenData = <T extends Array<SwaggerResponse<any>>>(
  pages?: T,
): GetDataType<T> | undefined =>
  pages?.flatMap((page) =>
    Array.isArray(page.data)
      ? page.data
      : Array.isArray(page.data?.data)
      ? page.data.data
      : Array.isArray(page.data?.list)
      ? page.data.list
      : [],
  ) as any;

const getTotal = <T extends Array<SwaggerResponse<any>>>(
  pages?: T,
): number | undefined => {
  return pages && pages[pages.length - 1]?.data?.total;
};

const getPageSize = (queryParams?: any): number | undefined => {
  const pageSize = Object.entries(queryParams || {}).find(([key, _value]) => {
    if (
      key.toLowerCase() === \\"pagesize\\" ||
      key.toLowerCase() === \\"pagenumber\\"
    ) {
      return true;
    }
    return false;
  });

  return (pageSize?.[1] || 10) as number;
};

export { paginationFlattenData, getTotal, getPageSize };
",
  "httpRequest.ts": "//@ts-nocheck
/**
 * AUTO_GENERATED Do not change this file directly, use config.ts file instead
 *
 * @version 6
 */

import axios, { AxiosRequestConfig, CancelToken } from \\"axios\\";
import { getAxiosInstance } from \\"./config\\";
import type { Security, SwaggerResponse } from \\"./config\\";

/**
 * Cancellation handled here, you can cancel request by call promise.cancel()
 *
 * @example
 *   const promise = getUsers();
 *   setTimeout(() => promise.cancel(), 30000);
 *   const { data } = await promise;
 *
 * @param getPromise
 * @returns
 */
function cancellation<T>(
  getPromise: (cancelToken: CancelToken) => Promise<T>,
): Promise<T> {
  const source = axios.CancelToken.source();
  const promise = getPromise(source.token);
  //@ts-ignore
  promise.cancel = () => {
    source.cancel(\\"request canceled\\");
  };

  return promise;
}

export const Http = {
  getRequest(
    url: string,
    queryParams: any | undefined,
    //@ts-ignore
    _requestBody: undefined,
    security: Security,
    configOverride?: AxiosRequestConfig,
  ): Promise<SwaggerResponse<any>> {
    return cancellation((cancelToken) =>
      getAxiosInstance(security).get(url, {
        cancelToken,
        params: queryParams,
        ...configOverride,
      }),
    );
  },
  postRequest(
    url: string,
    queryParams: any | undefined,
    requestBody: any | undefined,
    security: Security,
    configOverride?: AxiosRequestConfig,
  ): Promise<SwaggerResponse<any>> {
    return cancellation((cancelToken) =>
      getAxiosInstance(security).post(url, requestBody, {
        cancelToken,
        params: queryParams,
        ...configOverride,
      }),
    );
  },
  putRequest(
    url: string,
    queryParams: any | undefined,
    requestBody: any | undefined,
    security: Security,
    configOverride?: AxiosRequestConfig,
  ): Promise<SwaggerResponse<any>> {
    return cancellation((cancelToken) =>
      getAxiosInstance(security).put(url, requestBody, {
        cancelToken,
        params: queryParams,
        ...configOverride,
      }),
    );
  },
  patchRequest(
    url: string,
    queryParams: any | undefined,
    requestBody: any | undefined,
    security: Security,
    configOverride?: AxiosRequestConfig,
  ): Promise<SwaggerResponse<any>> {
    return cancellation((cancelToken) =>
      getAxiosInstance(security).patch(url, requestBody, {
        cancelToken,
        params: queryParams,
        ...configOverride,
      }),
    );
  },
  deleteRequest(
    url: string,
    queryParams: any | undefined,
    requestBody: any | undefined,
    security: Security,
    configOverride?: AxiosRequestConfig,
  ): Promise<SwaggerResponse<any>> {
    return cancellation((cancelToken) =>
      getAxiosInstance(security).delete(url, {
        data: requestBody,
        cancelToken,
        params: queryParams,
        ...configOverride,
      }),
    );
  },
};
",
  "services.ts": "//@ts-nocheck
/**
 * AUTO_GENERATED Do not change this file directly, use config.ts file instead
 *
 * @version 6
 */

import type { AxiosRequestConfig } from \\"axios\\";
import type { SwaggerResponse } from \\"./config\\";
import { Http } from \\"./httpRequest\\";
//@ts-ignore
import qs from \\"qs\\";
import type {
  GetAdminAppsApprovedListQueryParams,
  GetAdminAppsRequestsListQueryParams,
  GetAdminAppsRestrictedListQueryParams,
  GetAdminConversationsEkmListOriginalConnectedChannelInfoQueryParams,
  GetAdminConversationsGetConversationPrefsQueryParams,
  GetAdminConversationsGetTeamsQueryParams,
  GetAdminConversationsRestrictAccessListGroupsQueryParams,
  GetAdminConversationsSearchQueryParams,
  GetAdminEmojiListQueryParams,
  GetAdminInviteRequestsApprovedListQueryParams,
  GetAdminInviteRequestsDeniedListQueryParams,
  GetAdminInviteRequestsListQueryParams,
  GetAdminTeamsAdminsListQueryParams,
  GetAdminTeamsListQueryParams,
  GetAdminTeamsOwnersListQueryParams,
  GetAdminTeamsSettingsInfoQueryParams,
  GetAdminUsergroupsListChannelsQueryParams,
  GetAdminUsersListQueryParams,
  GetApiTestQueryParams,
  GetAppsEventAuthorizationsListQueryParams,
  GetAppsPermissionsInfoQueryParams,
  GetAppsPermissionsRequestQueryParams,
  GetAppsPermissionsResourcesListQueryParams,
  GetAppsPermissionsScopesListQueryParams,
  GetAppsPermissionsUsersListQueryParams,
  GetAppsPermissionsUsersRequestQueryParams,
  GetAppsUninstallQueryParams,
  GetAuthRevokeQueryParams,
  GetBotsInfoQueryParams,
  GetCallsInfoQueryParams,
  GetChatGetPermalinkQueryParams,
  GetChatScheduledMessagesListQueryParams,
  GetConversationsHistoryQueryParams,
  GetConversationsInfoQueryParams,
  GetConversationsListQueryParams,
  GetConversationsMembersQueryParams,
  GetConversationsRepliesQueryParams,
  GetDialogOpenQueryParams,
  GetDndInfoQueryParams,
  GetDndTeamInfoQueryParams,
  GetEmojiListQueryParams,
  GetFilesInfoQueryParams,
  GetFilesListQueryParams,
  GetFilesRemoteInfoQueryParams,
  GetFilesRemoteListQueryParams,
  GetFilesRemoteShareQueryParams,
  GetMigrationExchangeQueryParams,
  GetOauthAccessQueryParams,
  GetOauthTokenQueryParams,
  GetOauthV2AccessQueryParams,
  GetPinsListQueryParams,
  GetReactionsGetQueryParams,
  GetReactionsListQueryParams,
  GetRemindersInfoQueryParams,
  GetRemindersListQueryParams,
  GetRtmConnectQueryParams,
  GetSearchMessagesQueryParams,
  GetStarsListQueryParams,
  GetTeamAccessLogsQueryParams,
  GetTeamBillableInfoQueryParams,
  GetTeamInfoQueryParams,
  GetTeamIntegrationLogsQueryParams,
  GetTeamProfileGetQueryParams,
  GetUsergroupsListQueryParams,
  GetUsergroupsUsersListQueryParams,
  GetUsersConversationsQueryParams,
  GetUsersGetPresenceQueryParams,
  GetUsersIdentityQueryParams,
  GetUsersInfoQueryParams,
  GetUsersListQueryParams,
  GetUsersLookupByEmailQueryParams,
  GetUsersProfileGetQueryParams,
  GetViewsOpenQueryParams,
  GetViewsPublishQueryParams,
  GetViewsPushQueryParams,
  GetViewsUpdateQueryParams,
  GetWorkflowsStepCompletedQueryParams,
  GetWorkflowsStepFailedQueryParams,
  GetWorkflowsUpdateStepQueryParams,
  Defs_app_id,
  Defs_bot_id,
  Defs_channel,
  Defs_channel_id,
  Defs_dm_id,
  Defs_group_id,
  Defs_ok_true,
  Defs_team,
  Defs_ts,
  Defs_user_id,
  Objs_bot_profile,
  Objs_channel,
  Objs_comment,
  Objs_comments,
  Objs_conversation,
  Objs_file,
  Objs_message,
  Objs_paging,
  Objs_reminder,
  Objs_resources,
  Objs_response_metadata,
  Objs_scopes,
  Objs_subteam,
  Objs_team,
  Objs_team_profile_field,
  Objs_user,
  Objs_user_profile,
  Objs_user_profile_short,
} from \\"./types\\";

// eslint-disable-next-line @typescript-eslint/no-unused-vars
const __DEV__ = process.env.NODE_ENV !== \\"production\\";

// eslint-disable-next-line @typescript-eslint/no-unused-vars
function overrideConfig(
  config?: AxiosRequestConfig,
  configOverride?: AxiosRequestConfig,
): AxiosRequestConfig {
  return {
    ...config,
    ...configOverride,
    headers: {
      ...config?.headers,
      ...configOverride?.headers,
    },
  };
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function template(path: string, obj: { [x: string]: any } = {}) {
  Object.keys(obj).forEach((key) => {
    const re = new RegExp(\`{\${key}}\`, \\"i\\");
    path = path.replace(re, obj[key]);
  });

  return path;
}

function isFormData(obj: any) {
  // This checks for the append method which should exist on FormData instances
  return (
    (typeof obj === \\"object\\" &&
      typeof obj.append === \\"function\\" &&
      obj[Symbol.toStringTag] === undefined) ||
    obj[Symbol.toStringTag] === \\"FormData\\"
  );
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
function objToForm(requestBody: object) {
  if (isFormData(requestBody)) {
    return requestBody;
  }
  const formData = new FormData();

  Object.entries(requestBody).forEach(([key, value]) => {
    value && formData.append(key, value);
  });

  return formData;
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
function objToUrlencoded(requestBody: object) {
  return qs.stringify(requestBody);
}

export const getAdminAppsApprovedList = (
  queryParams: GetAdminAppsApprovedListQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getAdminAppsApprovedList.key,
    queryParams,
    undefined,
    _CONSTANT2,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getAdminAppsApprovedList.key = \\"/admin.apps.approved.list\\";

export const getAdminAppsRequestsList = (
  queryParams: GetAdminAppsRequestsListQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getAdminAppsRequestsList.key,
    queryParams,
    undefined,
    _CONSTANT2,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getAdminAppsRequestsList.key = \\"/admin.apps.requests.list\\";

export const getAdminAppsRestrictedList = (
  queryParams: GetAdminAppsRestrictedListQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getAdminAppsRestrictedList.key,
    queryParams,
    undefined,
    _CONSTANT2,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getAdminAppsRestrictedList.key = \\"/admin.apps.restricted.list\\";

export const getAdminConversationsEkmListOriginalConnectedChannelInfo = (
  queryParams: GetAdminConversationsEkmListOriginalConnectedChannelInfoQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getAdminConversationsEkmListOriginalConnectedChannelInfo.key,
    queryParams,
    undefined,
    _CONSTANT5,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getAdminConversationsEkmListOriginalConnectedChannelInfo.key =
  \\"/admin.conversations.ekm.listOriginalConnectedChannelInfo\\";

export const getAdminConversationsGetConversationPrefs = (
  queryParams: GetAdminConversationsGetConversationPrefsQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    ok: Defs_ok_true;
    prefs?: {
      can_thread?: { type?: string[]; user?: string[] };
      who_can_post?: { type?: string[]; user?: string[] };
    };
  }>
> => {
  return Http.getRequest(
    getAdminConversationsGetConversationPrefs.key,
    queryParams,
    undefined,
    _CONSTANT5,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT6,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
getAdminConversationsGetConversationPrefs.key =
  \\"/admin.conversations.getConversationPrefs\\";

export const getAdminConversationsGetTeams = (
  queryParams: GetAdminConversationsGetTeamsQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    ok: Defs_ok_true;
    team_ids: Defs_team[];
    response_metadata?: { next_cursor: string };
  }>
> => {
  return Http.getRequest(
    getAdminConversationsGetTeams.key,
    queryParams,
    undefined,
    _CONSTANT5,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT6,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
getAdminConversationsGetTeams.key = \\"/admin.conversations.getTeams\\";

export const getAdminConversationsRestrictAccessListGroups = (
  queryParams: GetAdminConversationsRestrictAccessListGroupsQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getAdminConversationsRestrictAccessListGroups.key,
    queryParams,
    undefined,
    _CONSTANT5,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getAdminConversationsRestrictAccessListGroups.key =
  \\"/admin.conversations.restrictAccess.listGroups\\";

export const getAdminConversationsSearch = (
  queryParams?: GetAdminConversationsSearchQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{ channels: Objs_channel[]; next_cursor: string }>
> => {
  return Http.getRequest(
    getAdminConversationsSearch.key,
    queryParams,
    undefined,
    _CONSTANT5,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT6,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
getAdminConversationsSearch.key = \\"/admin.conversations.search\\";

export const getAdminEmojiList = (
  queryParams: GetAdminEmojiListQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getAdminEmojiList.key,
    queryParams,
    undefined,
    _CONSTANT9,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getAdminEmojiList.key = \\"/admin.emoji.list\\";

export const getAdminInviteRequestsApprovedList = (
  queryParams?: GetAdminInviteRequestsApprovedListQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getAdminInviteRequestsApprovedList.key,
    queryParams,
    undefined,
    _CONSTANT11,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT6,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
getAdminInviteRequestsApprovedList.key = \\"/admin.inviteRequests.approved.list\\";

export const getAdminInviteRequestsDeniedList = (
  queryParams?: GetAdminInviteRequestsDeniedListQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getAdminInviteRequestsDeniedList.key,
    queryParams,
    undefined,
    _CONSTANT11,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT6,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
getAdminInviteRequestsDeniedList.key = \\"/admin.inviteRequests.denied.list\\";

export const getAdminInviteRequestsList = (
  queryParams?: GetAdminInviteRequestsListQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getAdminInviteRequestsList.key,
    queryParams,
    undefined,
    _CONSTANT11,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT6,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
getAdminInviteRequestsList.key = \\"/admin.inviteRequests.list\\";

export const getAdminTeamsAdminsList = (
  queryParams: GetAdminTeamsAdminsListQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getAdminTeamsAdminsList.key,
    queryParams,
    undefined,
    _CONSTANT9,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getAdminTeamsAdminsList.key = \\"/admin.teams.admins.list\\";

export const getAdminTeamsList = (
  queryParams?: GetAdminTeamsListQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getAdminTeamsList.key,
    queryParams,
    undefined,
    _CONSTANT9,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT6,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
getAdminTeamsList.key = \\"/admin.teams.list\\";

export const getAdminTeamsOwnersList = (
  queryParams: GetAdminTeamsOwnersListQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getAdminTeamsOwnersList.key,
    queryParams,
    undefined,
    _CONSTANT9,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getAdminTeamsOwnersList.key = \\"/admin.teams.owners.list\\";

export const getAdminTeamsSettingsInfo = (
  queryParams: GetAdminTeamsSettingsInfoQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getAdminTeamsSettingsInfo.key,
    queryParams,
    undefined,
    _CONSTANT9,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT6,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
getAdminTeamsSettingsInfo.key = \\"/admin.teams.settings.info\\";

export const getAdminUsergroupsListChannels = (
  queryParams: GetAdminUsergroupsListChannelsQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getAdminUsergroupsListChannels.key,
    queryParams,
    undefined,
    _CONSTANT13,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT6,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
getAdminUsergroupsListChannels.key = \\"/admin.usergroups.listChannels\\";

export const getAdminUsersList = (
  queryParams: GetAdminUsersListQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getAdminUsersList.key,
    queryParams,
    undefined,
    _CONSTANT15,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT6,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
getAdminUsersList.key = \\"/admin.users.list\\";

export const getApiTest = (
  queryParams?: GetApiTestQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getApiTest.key,
    queryParams,
    undefined,
    _CONSTANT16,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getApiTest.key = \\"/api.test\\";

export const getAppsEventAuthorizationsList = (
  queryParams: GetAppsEventAuthorizationsListQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getAppsEventAuthorizationsList.key,
    queryParams,
    undefined,
    _CONSTANT17,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT6,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
getAppsEventAuthorizationsList.key = \\"/apps.event.authorizations.list\\";

export const getAppsPermissionsInfo = (
  queryParams?: GetAppsPermissionsInfoQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    info: {
      app_home: { resources?: Objs_resources; scopes?: Objs_scopes };
      channel: { resources?: Objs_resources; scopes?: Objs_scopes };
      group: { resources?: Objs_resources; scopes?: Objs_scopes };
      im: { resources?: Objs_resources; scopes?: Objs_scopes };
      mpim: { resources?: Objs_resources; scopes?: Objs_scopes };
      team: { resources: Objs_resources; scopes: Objs_scopes };
    };
    ok: Defs_ok_true;
  }>
> => {
  return Http.getRequest(
    getAppsPermissionsInfo.key,
    queryParams,
    undefined,
    _CONSTANT16,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getAppsPermissionsInfo.key = \\"/apps.permissions.info\\";

export const getAppsPermissionsRequest = (
  queryParams: GetAppsPermissionsRequestQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getAppsPermissionsRequest.key,
    queryParams,
    undefined,
    _CONSTANT16,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getAppsPermissionsRequest.key = \\"/apps.permissions.request\\";

export const getAppsPermissionsResourcesList = (
  queryParams: GetAppsPermissionsResourcesListQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    ok: Defs_ok_true;
    resources: {
      /** An ID for a resource */
      id?: string;
      /** The type of resource the \`id\` corresponds to */
      type?: string;
    }[];
    response_metadata?: { next_cursor: string };
  }>
> => {
  return Http.getRequest(
    getAppsPermissionsResourcesList.key,
    queryParams,
    undefined,
    _CONSTANT16,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getAppsPermissionsResourcesList.key = \\"/apps.permissions.resources.list\\";

export const getAppsPermissionsScopesList = (
  queryParams: GetAppsPermissionsScopesListQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    ok: Defs_ok_true;
    scopes: {
      app_home?: Objs_scopes;
      channel?: Objs_scopes;
      group?: Objs_scopes;
      im?: Objs_scopes;
      mpim?: Objs_scopes;
      team?: Objs_scopes;
      user?: Objs_scopes;
    };
  }>
> => {
  return Http.getRequest(
    getAppsPermissionsScopesList.key,
    queryParams,
    undefined,
    _CONSTANT16,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getAppsPermissionsScopesList.key = \\"/apps.permissions.scopes.list\\";

export const getAppsPermissionsUsersList = (
  queryParams: GetAppsPermissionsUsersListQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getAppsPermissionsUsersList.key,
    queryParams,
    undefined,
    _CONSTANT16,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getAppsPermissionsUsersList.key = \\"/apps.permissions.users.list\\";

export const getAppsPermissionsUsersRequest = (
  queryParams: GetAppsPermissionsUsersRequestQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getAppsPermissionsUsersRequest.key,
    queryParams,
    undefined,
    _CONSTANT16,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getAppsPermissionsUsersRequest.key = \\"/apps.permissions.users.request\\";

export const getAppsUninstall = (
  queryParams?: GetAppsUninstallQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getAppsUninstall.key,
    queryParams,
    undefined,
    _CONSTANT16,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getAppsUninstall.key = \\"/apps.uninstall\\";

export const getAuthRevoke = (
  queryParams: GetAuthRevokeQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true; revoked: boolean }>> => {
  return Http.getRequest(
    getAuthRevoke.key,
    queryParams,
    undefined,
    _CONSTANT16,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getAuthRevoke.key = \\"/auth.revoke\\";

export const getAuthTest = (
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    ok: Defs_ok_true;
    team: string;
    team_id: Defs_team;
    url: string;
    user: string;
    user_id: Defs_user_id;
    bot_id?: Defs_bot_id;
    is_enterprise_install?: boolean;
  }>
> => {
  return Http.getRequest(
    getAuthTest.key,
    undefined,
    undefined,
    _CONSTANT16,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT6,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
getAuthTest.key = \\"/auth.test\\";

export const getBotsInfo = (
  queryParams: GetBotsInfoQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    bot: {
      app_id: Defs_app_id;
      deleted: boolean;
      icons: {
        /** - Format: uri */
        image_36: string;
        /** - Format: uri */
        image_48: string;
        /** - Format: uri */
        image_72: string;
      };
      id: Defs_bot_id;
      name: string;
      updated: number;
      user_id?: Defs_user_id;
    };
    ok: Defs_ok_true;
  }>
> => {
  return Http.getRequest(
    getBotsInfo.key,
    queryParams,
    undefined,
    _CONSTANT18,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getBotsInfo.key = \\"/bots.info\\";

export const getCallsInfo = (
  queryParams: GetCallsInfoQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getCallsInfo.key,
    queryParams,
    undefined,
    _CONSTANT20,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT6,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
getCallsInfo.key = \\"/calls.info\\";

export const getChatGetPermalink = (
  queryParams: GetChatGetPermalinkQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    channel: Defs_channel;
    ok: Defs_ok_true;
    /** - Format: uri */
    permalink: string;
  }>
> => {
  return Http.getRequest(
    getChatGetPermalink.key,
    queryParams,
    undefined,
    _CONSTANT16,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getChatGetPermalink.key = \\"/chat.getPermalink\\";

export const getChatScheduledMessagesList = (
  queryParams?: GetChatScheduledMessagesListQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    ok: Defs_ok_true;
    response_metadata: { next_cursor: string };
    scheduled_messages: {
      channel_id: Defs_channel_id;
      /** - Pattern: ^\\\\d{10}$ */
      date_created: number;
      /** - Pattern: ^[Q][A-Z0-9]{8,}$ */
      id: string;
      /** - Pattern: ^\\\\d{10}$ */
      post_at: number;
      text?: string;
    }[];
  }>
> => {
  return Http.getRequest(
    getChatScheduledMessagesList.key,
    queryParams,
    undefined,
    _CONSTANT16,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT6,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
getChatScheduledMessagesList.key = \\"/chat.scheduledMessages.list\\";

export const getConversationsHistory = (
  queryParams?: GetConversationsHistoryQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    channel_actions_count: number;
    channel_actions_ts: (number | null)[];
    has_more: boolean;
    messages: Objs_message[];
    ok: Defs_ok_true;
    pin_count: number;
  }>
> => {
  return Http.getRequest(
    getConversationsHistory.key,
    queryParams,
    undefined,
    _CONSTANT24,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getConversationsHistory.key = \\"/conversations.history\\";

export const getConversationsInfo = (
  queryParams?: GetConversationsInfoQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{ channel: Objs_conversation; ok: Defs_ok_true }>
> => {
  return Http.getRequest(
    getConversationsInfo.key,
    queryParams,
    undefined,
    _CONSTANT25,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getConversationsInfo.key = \\"/conversations.info\\";

export const getConversationsList = (
  queryParams?: GetConversationsListQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    channels: Objs_conversation[];
    ok: Defs_ok_true;
    response_metadata?: { next_cursor: string };
  }>
> => {
  return Http.getRequest(
    getConversationsList.key,
    queryParams,
    undefined,
    _CONSTANT25,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getConversationsList.key = \\"/conversations.list\\";

export const getConversationsMembers = (
  queryParams?: GetConversationsMembersQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    members: Defs_user_id[];
    ok: Defs_ok_true;
    response_metadata: { next_cursor: string };
  }>
> => {
  return Http.getRequest(
    getConversationsMembers.key,
    queryParams,
    undefined,
    _CONSTANT25,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getConversationsMembers.key = \\"/conversations.members\\";

export const getConversationsReplies = (
  queryParams?: GetConversationsRepliesQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    messages: (
      | {
          reply_count: number;
          subscribed: boolean;
          text: string;
          thread_ts: Defs_ts;
          ts: Defs_ts;
          type: string;
          user: Defs_user_id;
          last_read?: Defs_ts;
          latest_reply?: Defs_ts;
          reply_users?: Defs_user_id[];
          reply_users_count?: number;
          source_team?: Defs_team;
          team?: Defs_team;
          unread_count?: number;
          user_profile?: Objs_user_profile_short;
          user_team?: Defs_team;
        }
      | {
          parent_user_id: Defs_user_id;
          text: string;
          thread_ts: Defs_ts;
          ts: Defs_ts;
          type: string;
          user: Defs_user_id;
          is_starred?: boolean;
          source_team?: Defs_team;
          team?: Defs_team;
          user_profile?: Objs_user_profile_short;
          user_team?: Defs_team;
        }
    )[][];
    ok: Defs_ok_true;
    has_more?: boolean;
  }>
> => {
  return Http.getRequest(
    getConversationsReplies.key,
    queryParams,
    undefined,
    _CONSTANT24,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getConversationsReplies.key = \\"/conversations.replies\\";

export const getDialogOpen = (
  queryParams: GetDialogOpenQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getDialogOpen.key,
    queryParams,
    undefined,
    _CONSTANT16,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT6,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
getDialogOpen.key = \\"/dialog.open\\";

export const getDndInfo = (
  queryParams?: GetDndInfoQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    dnd_enabled: boolean;
    next_dnd_end_ts: number;
    next_dnd_start_ts: number;
    ok: Defs_ok_true;
    snooze_enabled?: boolean;
    snooze_endtime?: number;
    snooze_remaining?: number;
  }>
> => {
  return Http.getRequest(
    getDndInfo.key,
    queryParams,
    undefined,
    _CONSTANT28,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getDndInfo.key = \\"/dnd.info\\";

export const getDndTeamInfo = (
  queryParams?: GetDndTeamInfoQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getDndTeamInfo.key,
    queryParams,
    undefined,
    _CONSTANT28,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getDndTeamInfo.key = \\"/dnd.teamInfo\\";

export const getEmojiList = (
  queryParams: GetEmojiListQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getEmojiList.key,
    queryParams,
    undefined,
    _CONSTANT29,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getEmojiList.key = \\"/emoji.list\\";

export const getFilesInfo = (
  queryParams?: GetFilesInfoQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    comments: Objs_comments;
    file: Objs_file;
    ok: Defs_ok_true;
    content_html?: null;
    editor?: Defs_user_id;
    paging?: Objs_paging;
    response_metadata?: Objs_response_metadata;
  }>
> => {
  return Http.getRequest(
    getFilesInfo.key,
    queryParams,
    undefined,
    _CONSTANT31,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getFilesInfo.key = \\"/files.info\\";

export const getFilesList = (
  queryParams?: GetFilesListQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{ files: Objs_file[]; ok: Defs_ok_true; paging: Objs_paging }>
> => {
  return Http.getRequest(
    getFilesList.key,
    queryParams,
    undefined,
    _CONSTANT31,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getFilesList.key = \\"/files.list\\";

export const getFilesRemoteInfo = (
  queryParams?: GetFilesRemoteInfoQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getFilesRemoteInfo.key,
    queryParams,
    undefined,
    _CONSTANT33,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getFilesRemoteInfo.key = \\"/files.remote.info\\";

export const getFilesRemoteList = (
  queryParams?: GetFilesRemoteListQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getFilesRemoteList.key,
    queryParams,
    undefined,
    _CONSTANT33,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getFilesRemoteList.key = \\"/files.remote.list\\";

export const getFilesRemoteShare = (
  queryParams?: GetFilesRemoteShareQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getFilesRemoteShare.key,
    queryParams,
    undefined,
    _CONSTANT34,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getFilesRemoteShare.key = \\"/files.remote.share\\";

export const getMigrationExchange = (
  queryParams: GetMigrationExchangeQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    /** The enterprise grid organization ID containing the workspace/team. */
    enterprise_id: string;
    ok: Defs_ok_true;
    team_id: Defs_team;
    /** A list of User IDs that cannot be mapped or found */
    invalid_user_ids?: string[];
    /** A mapping of provided user IDs with mapped user IDs */
    user_id_map?: { [x: string]: any };
  }>
> => {
  return Http.getRequest(
    getMigrationExchange.key,
    queryParams,
    undefined,
    _CONSTANT35,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getMigrationExchange.key = \\"/migration.exchange\\";

export const getOauthAccess = (
  queryParams?: GetOauthAccessQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getOauthAccess.key,
    queryParams,
    undefined,
    _CONSTANT16,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getOauthAccess.key = \\"/oauth.access\\";

export const getOauthToken = (
  queryParams?: GetOauthTokenQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getOauthToken.key,
    queryParams,
    undefined,
    _CONSTANT16,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getOauthToken.key = \\"/oauth.token\\";

export const getOauthV2Access = (
  queryParams: GetOauthV2AccessQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getOauthV2Access.key,
    queryParams,
    undefined,
    _CONSTANT16,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getOauthV2Access.key = \\"/oauth.v2.access\\";

export const getPinsList = (
  queryParams: GetPinsListQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<
    (
      | {
          items: (
            | {
                created?: number;
                created_by?: Defs_user_id;
                file?: Objs_file;
                type?: \\"file\\";
              }
            | {
                channel?: Defs_channel;
                created?: number;
                created_by?: Defs_user_id;
                message?: Objs_message;
                type?: \\"message\\";
              }
          )[];
          ok: Defs_ok_true;
        }
      | { count: number; ok: Defs_ok_true }
    )[]
  >
> => {
  return Http.getRequest(
    getPinsList.key,
    queryParams,
    undefined,
    _CONSTANT37,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getPinsList.key = \\"/pins.list\\";

export const getReactionsGet = (
  queryParams: GetReactionsGetQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<
    (
      | {
          channel: Defs_channel;
          message: Objs_message;
          ok: Defs_ok_true;
          type: \\"message\\";
        }
      | { file: Objs_file; ok: Defs_ok_true; type: \\"file\\" }
      | {
          comment: Objs_comment;
          file: Objs_file;
          ok: Defs_ok_true;
          type: \\"file_comment\\";
        }
    )[]
  >
> => {
  return Http.getRequest(
    getReactionsGet.key,
    queryParams,
    undefined,
    _CONSTANT39,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getReactionsGet.key = \\"/reactions.get\\";

export const getReactionsList = (
  queryParams: GetReactionsListQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    items: (
      | { channel: Defs_channel; message: Objs_message; type: \\"message\\" }
      | { file: Objs_file; type: \\"file\\" }
      | { comment: Objs_comment; file: Objs_file; type: \\"file_comment\\" }
    )[][];
    ok: Defs_ok_true;
    paging?: Objs_paging;
    response_metadata?: Objs_response_metadata;
  }>
> => {
  return Http.getRequest(
    getReactionsList.key,
    queryParams,
    undefined,
    _CONSTANT39,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getReactionsList.key = \\"/reactions.list\\";

export const getRemindersInfo = (
  queryParams?: GetRemindersInfoQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true; reminder: Objs_reminder }>> => {
  return Http.getRequest(
    getRemindersInfo.key,
    queryParams,
    undefined,
    _CONSTANT41,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getRemindersInfo.key = \\"/reminders.info\\";

export const getRemindersList = (
  queryParams?: GetRemindersListQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{ ok: Defs_ok_true; reminders: Objs_reminder[] }>
> => {
  return Http.getRequest(
    getRemindersList.key,
    queryParams,
    undefined,
    _CONSTANT41,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getRemindersList.key = \\"/reminders.list\\";

export const getRtmConnect = (
  queryParams: GetRtmConnectQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    ok: Defs_ok_true;
    self: { id: Defs_user_id; name: string };
    team: { domain: string; id: Defs_team; name: string };
    /** - Format: uri */
    url: string;
  }>
> => {
  return Http.getRequest(
    getRtmConnect.key,
    queryParams,
    undefined,
    _CONSTANT42,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getRtmConnect.key = \\"/rtm.connect\\";

export const getSearchMessages = (
  queryParams: GetSearchMessagesQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getSearchMessages.key,
    queryParams,
    undefined,
    _CONSTANT43,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getSearchMessages.key = \\"/search.messages\\";

export const getStarsList = (
  queryParams?: GetStarsListQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    items: (
      | {
          channel: Defs_channel;
          date_create: number;
          message: Objs_message;
          type: \\"message\\";
        }
      | { date_create: number; file: Objs_file; type: \\"file\\" }
      | {
          comment: Objs_comment;
          date_create: number;
          file: Objs_file;
          type: \\"file_comment\\";
        }
      | { channel: Defs_channel; date_create: number; type: \\"channel\\" }
      | { channel: Defs_dm_id; date_create: number; type: \\"im\\" }
      | { channel: Defs_group_id; date_create: number; type: \\"group\\" }
    )[][];
    ok: Defs_ok_true;
    paging?: Objs_paging;
  }>
> => {
  return Http.getRequest(
    getStarsList.key,
    queryParams,
    undefined,
    _CONSTANT45,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getStarsList.key = \\"/stars.list\\";

export const getTeamAccessLogs = (
  queryParams: GetTeamAccessLogsQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    logins: {
      count: number;
      date_first: number;
      date_last: number;
      user_agent: string;
      user_id: Defs_user_id;
      username: string;
      country?: string;
      ip?: string;
      isp?: string;
      region?: string;
    }[];
    ok: Defs_ok_true;
    paging: Objs_paging;
  }>
> => {
  return Http.getRequest(
    getTeamAccessLogs.key,
    queryParams,
    undefined,
    _CONSTANT46,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getTeamAccessLogs.key = \\"/team.accessLogs\\";

export const getTeamBillableInfo = (
  queryParams: GetTeamBillableInfoQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getTeamBillableInfo.key,
    queryParams,
    undefined,
    _CONSTANT46,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getTeamBillableInfo.key = \\"/team.billableInfo\\";

export const getTeamInfo = (
  queryParams: GetTeamInfoQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true; team: Objs_team }>> => {
  return Http.getRequest(
    getTeamInfo.key,
    queryParams,
    undefined,
    _CONSTANT47,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getTeamInfo.key = \\"/team.info\\";

export const getTeamIntegrationLogs = (
  queryParams: GetTeamIntegrationLogsQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    logs: {
      app_id: Defs_app_id;
      app_type: string;
      change_type: string;
      date: string;
      scope: string;
      user_id: Defs_user_id;
      user_name: string;
      admin_app_id?: Defs_app_id;
      channel?: Defs_channel;
      service_id?: string;
      service_type?: string;
    }[];
    ok: Defs_ok_true;
    paging: Objs_paging;
  }>
> => {
  return Http.getRequest(
    getTeamIntegrationLogs.key,
    queryParams,
    undefined,
    _CONSTANT46,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getTeamIntegrationLogs.key = \\"/team.integrationLogs\\";

export const getTeamProfileGet = (
  queryParams: GetTeamProfileGetQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    ok: Defs_ok_true;
    profile: { fields: Objs_team_profile_field[] };
  }>
> => {
  return Http.getRequest(
    getTeamProfileGet.key,
    queryParams,
    undefined,
    _CONSTANT48,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getTeamProfileGet.key = \\"/team.profile.get\\";

export const getUsergroupsList = (
  queryParams: GetUsergroupsListQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{ ok: Defs_ok_true; usergroups: Objs_subteam[] }>
> => {
  return Http.getRequest(
    getUsergroupsList.key,
    queryParams,
    undefined,
    _CONSTANT50,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getUsergroupsList.key = \\"/usergroups.list\\";

export const getUsergroupsUsersList = (
  queryParams: GetUsergroupsUsersListQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true; users: Defs_user_id[] }>> => {
  return Http.getRequest(
    getUsergroupsUsersList.key,
    queryParams,
    undefined,
    _CONSTANT50,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getUsergroupsUsersList.key = \\"/usergroups.users.list\\";

export const getUsersConversations = (
  queryParams?: GetUsersConversationsQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    channels: Objs_conversation[];
    ok: Defs_ok_true;
    response_metadata?: { next_cursor: string };
  }>
> => {
  return Http.getRequest(
    getUsersConversations.key,
    queryParams,
    undefined,
    _CONSTANT25,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getUsersConversations.key = \\"/users.conversations\\";

export const getUsersGetPresence = (
  queryParams: GetUsersGetPresenceQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    ok: Defs_ok_true;
    presence: string;
    auto_away?: boolean;
    connection_count?: number;
    last_activity?: number;
    manual_away?: boolean;
    online?: boolean;
  }>
> => {
  return Http.getRequest(
    getUsersGetPresence.key,
    queryParams,
    undefined,
    _CONSTANT18,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getUsersGetPresence.key = \\"/users.getPresence\\";

export const getUsersIdentity = (
  queryParams?: GetUsersIdentityQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<
    (
      | {
          ok: Defs_ok_true;
          team: { id: Defs_team };
          user: { id: Defs_user_id; name: string };
        }
      | {
          ok: Defs_ok_true;
          team: { id: Defs_team };
          user: {
            /** - Format: email */
            email: string;
            id: Defs_user_id;
            name: string;
          };
        }
      | {
          ok: Defs_ok_true;
          team: { id: Defs_team };
          user: {
            id: Defs_user_id;
            /** - Format: url */
            image_192: string;
            /** - Format: url */
            image_24: string;
            /** - Format: url */
            image_32: string;
            /** - Format: url */
            image_48: string;
            /** - Format: url */
            image_512: string;
            /** - Format: url */
            image_72: string;
            name: string;
          };
        }
      | {
          ok: Defs_ok_true;
          team: {
            domain: string;
            id: Defs_team;
            /** - Format: url */
            image_102: string;
            /** - Format: url */
            image_132: string;
            /** - Format: url */
            image_230: string;
            /** - Format: url */
            image_34: string;
            /** - Format: url */
            image_44: string;
            /** - Format: url */
            image_68: string;
            /** - Format: url */
            image_88: string;
            image_default: boolean;
            name: string;
          };
          user: { id: Defs_user_id; name: string };
        }
    )[]
  >
> => {
  return Http.getRequest(
    getUsersIdentity.key,
    queryParams,
    undefined,
    _CONSTANT52,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getUsersIdentity.key = \\"/users.identity\\";

export const getUsersInfo = (
  queryParams: GetUsersInfoQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true; user: Objs_user }>> => {
  return Http.getRequest(
    getUsersInfo.key,
    queryParams,
    undefined,
    _CONSTANT18,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getUsersInfo.key = \\"/users.info\\";

export const getUsersList = (
  queryParams?: GetUsersListQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    cache_ts: number;
    members: Objs_user[];
    ok: Defs_ok_true;
    response_metadata?: Objs_response_metadata;
  }>
> => {
  return Http.getRequest(
    getUsersList.key,
    queryParams,
    undefined,
    _CONSTANT18,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getUsersList.key = \\"/users.list\\";

export const getUsersLookupByEmail = (
  queryParams: GetUsersLookupByEmailQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true; user: Objs_user }>> => {
  return Http.getRequest(
    getUsersLookupByEmail.key,
    queryParams,
    undefined,
    _CONSTANT53,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getUsersLookupByEmail.key = \\"/users.lookupByEmail\\";

export const getUsersProfileGet = (
  queryParams: GetUsersProfileGetQueryParams,
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{ ok: Defs_ok_true; profile: Objs_user_profile }>
> => {
  return Http.getRequest(
    getUsersProfileGet.key,
    queryParams,
    undefined,
    _CONSTANT48,
    overrideConfig(_CONSTANT3, configOverride),
  );
};

/** Key is end point string without base url */
getUsersProfileGet.key = \\"/users.profile.get\\";

export const getViewsOpen = (
  queryParams: GetViewsOpenQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getViewsOpen.key,
    queryParams,
    undefined,
    _CONSTANT16,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT6,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
getViewsOpen.key = \\"/views.open\\";

export const getViewsPublish = (
  queryParams: GetViewsPublishQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getViewsPublish.key,
    queryParams,
    undefined,
    _CONSTANT16,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT6,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
getViewsPublish.key = \\"/views.publish\\";

export const getViewsPush = (
  queryParams: GetViewsPushQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getViewsPush.key,
    queryParams,
    undefined,
    _CONSTANT16,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT6,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
getViewsPush.key = \\"/views.push\\";

export const getViewsUpdate = (
  queryParams?: GetViewsUpdateQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getViewsUpdate.key,
    queryParams,
    undefined,
    _CONSTANT16,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT6,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
getViewsUpdate.key = \\"/views.update\\";

export const getWorkflowsStepCompleted = (
  queryParams: GetWorkflowsStepCompletedQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getWorkflowsStepCompleted.key,
    queryParams,
    undefined,
    _CONSTANT55,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT6,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
getWorkflowsStepCompleted.key = \\"/workflows.stepCompleted\\";

export const getWorkflowsStepFailed = (
  queryParams: GetWorkflowsStepFailedQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getWorkflowsStepFailed.key,
    queryParams,
    undefined,
    _CONSTANT55,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT6,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
getWorkflowsStepFailed.key = \\"/workflows.stepFailed\\";

export const getWorkflowsUpdateStep = (
  queryParams: GetWorkflowsUpdateStepQueryParams,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.getRequest(
    getWorkflowsUpdateStep.key,
    queryParams,
    undefined,
    _CONSTANT55,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT6,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
getWorkflowsUpdateStep.key = \\"/workflows.updateStep\\";

export const postAdminAppsApprove = (
  requestBody: {
    /** The id of the app to approve. */
    app_id?: string;
    /** The id of the request to approve. */
    request_id?: string;
    team_id?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminAppsApprove.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT0,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postAdminAppsApprove.key = \\"/admin.apps.approve\\";

export const postAdminAppsRestrict = (
  requestBody: {
    /** The id of the app to restrict. */
    app_id?: string;
    /** The id of the request to restrict. */
    request_id?: string;
    team_id?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminAppsRestrict.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT0,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postAdminAppsRestrict.key = \\"/admin.apps.restrict\\";

export const postAdminConversationsArchive = (
  requestBody: {
    /** The channel to archive. */
    channel_id: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminConversationsArchive.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT4,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postAdminConversationsArchive.key = \\"/admin.conversations.archive\\";

export const postAdminConversationsConvertToPrivate = (
  requestBody: {
    /** The channel to convert to private. */
    channel_id: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminConversationsConvertToPrivate.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT4,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postAdminConversationsConvertToPrivate.key =
  \\"/admin.conversations.convertToPrivate\\";

export const postAdminConversationsCreate = (
  requestBody: {
    /** When \`true\`, creates a private channel instead of a public channel */
    is_private: boolean;
    /** Name of the public or private channel to create. */
    name: string;
    /** Description of the public or private channel to create. */
    description?: string;
    /**
     * When \`true\`, the channel will be available org-wide. Note: if the channel is
     * not \`org_wide=true\`, you must specify a \`team_id\` for this channel
     */
    org_wide?: boolean;
    /**
     * The workspace to create the channel in. Note: this argument is required
     * unless you set \`org_wide=true\`.
     */
    team_id?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{ ok: Defs_ok_true; channel_id?: Defs_channel_id }>
> => {
  return Http.postRequest(
    postAdminConversationsCreate.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT4,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postAdminConversationsCreate.key = \\"/admin.conversations.create\\";

export const postAdminConversationsDelete = (
  requestBody: {
    /** The channel to delete. */
    channel_id: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminConversationsDelete.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT4,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postAdminConversationsDelete.key = \\"/admin.conversations.delete\\";

export const postAdminConversationsDisconnectShared = (
  requestBody: {
    /** The channel to be disconnected from some workspaces. */
    channel_id: string;
    /**
     * The team to be removed from the channel. Currently only a single team id can
     * be specified.
     */
    leaving_team_ids?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminConversationsDisconnectShared.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT4,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postAdminConversationsDisconnectShared.key =
  \\"/admin.conversations.disconnectShared\\";

export const postAdminConversationsInvite = (
  requestBody: {
    /** The channel that the users will be invited to. */
    channel_id: string;
    /** The users to invite. */
    user_ids: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminConversationsInvite.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT4,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postAdminConversationsInvite.key = \\"/admin.conversations.invite\\";

export const postAdminConversationsRename = (
  requestBody: {
    /** The channel to rename. */
    channel_id: string;
    name: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminConversationsRename.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT4,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postAdminConversationsRename.key = \\"/admin.conversations.rename\\";

export const postAdminConversationsRestrictAccessAddGroup = (
  requestBody: {
    /** The channel to link this group to. */
    channel_id: string;
    /**
     * The [IDP
     * Group](https://slack.com/help/articles/115001435788-Connect-identity-provider-groups-to-your-Enterprise-Grid-org)
     * ID to be an allowlist for the private channel.
     */
    group_id: string;
    /** Authentication token. Requires scope: \`admin.conversations:write\` */
    token: string;
    /**
     * The workspace where the channel exists. This argument is required for
     * channels only tied to one workspace, and optional for channels that are
     * shared across an organization.
     */
    team_id?: string;
  },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminConversationsRestrictAccessAddGroup.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT4,
    overrideConfig(_CONSTANT7, configOverride),
  );
};

/** Key is end point string without base url */
postAdminConversationsRestrictAccessAddGroup.key =
  \\"/admin.conversations.restrictAccess.addGroup\\";

export const postAdminConversationsRestrictAccessRemoveGroup = (
  requestBody: {
    /** The channel to remove the linked group from. */
    channel_id: string;
    /**
     * The [IDP
     * Group](https://slack.com/help/articles/115001435788-Connect-identity-provider-groups-to-your-Enterprise-Grid-org)
     * ID to remove from the private channel.
     */
    group_id: string;
    /**
     * The workspace where the channel exists. This argument is required for
     * channels only tied to one workspace, and optional for channels that are
     * shared across an organization.
     */
    team_id: string;
    /** Authentication token. Requires scope: \`admin.conversations:write\` */
    token: string;
  },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminConversationsRestrictAccessRemoveGroup.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT4,
    overrideConfig(_CONSTANT7, configOverride),
  );
};

/** Key is end point string without base url */
postAdminConversationsRestrictAccessRemoveGroup.key =
  \\"/admin.conversations.restrictAccess.removeGroup\\";

export const postAdminConversationsSetConversationPrefs = (
  requestBody: {
    /** The channel to set the prefs for */
    channel_id: string;
    /** The prefs for this channel in a stringified JSON format. */
    prefs: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminConversationsSetConversationPrefs.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT4,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postAdminConversationsSetConversationPrefs.key =
  \\"/admin.conversations.setConversationPrefs\\";

export const postAdminConversationsSetTeams = (
  requestBody: {
    /** The encoded \`channel_id\` to add or remove to workspaces. */
    channel_id: string;
    /** True if channel has to be converted to an org channel */
    org_channel?: boolean;
    /**
     * A comma-separated list of workspaces to which the channel should be shared.
     * Not required if the channel is being shared org-wide.
     */
    target_team_ids?: string;
    /**
     * The workspace to which the channel belongs. Omit this argument if the channel
     * is a cross-workspace shared channel.
     */
    team_id?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminConversationsSetTeams.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT4,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postAdminConversationsSetTeams.key = \\"/admin.conversations.setTeams\\";

export const postAdminConversationsUnarchive = (
  requestBody: {
    /** The channel to unarchive. */
    channel_id: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminConversationsUnarchive.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT4,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postAdminConversationsUnarchive.key = \\"/admin.conversations.unarchive\\";

export const postAdminEmojiAdd = (
  requestBody: {
    /**
     * The name of the emoji to be removed. Colons (\`:myemoji:\`) around the value
     * are not required, although they may be included.
     */
    name: string;
    /** Authentication token. Requires scope: \`admin.teams:write\` */
    token: string;
    /**
     * The URL of a file to use as an image for the emoji. Square images under 128KB
     * and with transparent backgrounds work best.
     */
    url: string;
  },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminEmojiAdd.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT8,
    overrideConfig(_CONSTANT7, configOverride),
  );
};

/** Key is end point string without base url */
postAdminEmojiAdd.key = \\"/admin.emoji.add\\";

export const postAdminEmojiAddAlias = (
  requestBody: {
    /** The alias of the emoji. */
    alias_for: string;
    /**
     * The name of the emoji to be aliased. Colons (\`:myemoji:\`) around the value
     * are not required, although they may be included.
     */
    name: string;
    /** Authentication token. Requires scope: \`admin.teams:write\` */
    token: string;
  },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminEmojiAddAlias.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT8,
    overrideConfig(_CONSTANT7, configOverride),
  );
};

/** Key is end point string without base url */
postAdminEmojiAddAlias.key = \\"/admin.emoji.addAlias\\";

export const postAdminEmojiRemove = (
  requestBody: {
    /**
     * The name of the emoji to be removed. Colons (\`:myemoji:\`) around the value
     * are not required, although they may be included.
     */
    name: string;
    /** Authentication token. Requires scope: \`admin.teams:write\` */
    token: string;
  },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminEmojiRemove.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT8,
    overrideConfig(_CONSTANT7, configOverride),
  );
};

/** Key is end point string without base url */
postAdminEmojiRemove.key = \\"/admin.emoji.remove\\";

export const postAdminEmojiRename = (
  requestBody: {
    /**
     * The name of the emoji to be renamed. Colons (\`:myemoji:\`) around the value
     * are not required, although they may be included.
     */
    name: string;
    /** The new name of the emoji. */
    new_name: string;
    /** Authentication token. Requires scope: \`admin.teams:write\` */
    token: string;
  },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminEmojiRename.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT8,
    overrideConfig(_CONSTANT7, configOverride),
  );
};

/** Key is end point string without base url */
postAdminEmojiRename.key = \\"/admin.emoji.rename\\";

export const postAdminInviteRequestsApprove = (
  requestBody: RequestBodyAdmin_inviteRequests_approve,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminInviteRequestsApprove.key,
    undefined,
    requestBody,
    _CONSTANT10,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT6,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postAdminInviteRequestsApprove.key = \\"/admin.inviteRequests.approve\\";

export const postAdminInviteRequestsDeny = (
  requestBody: RequestBodyAdmin_inviteRequests_approve,
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminInviteRequestsDeny.key,
    undefined,
    requestBody,
    _CONSTANT10,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT6,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postAdminInviteRequestsDeny.key = \\"/admin.inviteRequests.deny\\";

export const postAdminTeamsCreate = (
  requestBody: {
    /** Team domain (for example, slacksoftballteam). */
    team_domain: string;
    /** Team name (for example, Slack Softball Team). */
    team_name: string;
    /** Description for the team. */
    team_description?: string;
    /**
     * Who can join the team. A team's discoverability can be \`open\`, \`closed\`,
     * \`invite_only\`, or \`unlisted\`.
     */
    team_discoverability?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminTeamsCreate.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT8,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postAdminTeamsCreate.key = \\"/admin.teams.create\\";

export const postAdminTeamsSettingsSetDefaultChannels = (
  requestBody: {
    /** An array of channel IDs. */
    channel_ids: string;
    /** ID for the workspace to set the default channel for. */
    team_id: string;
    /** Authentication token. Requires scope: \`admin.teams:write\` */
    token: string;
  },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminTeamsSettingsSetDefaultChannels.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT8,
    overrideConfig(_CONSTANT7, configOverride),
  );
};

/** Key is end point string without base url */
postAdminTeamsSettingsSetDefaultChannels.key =
  \\"/admin.teams.settings.setDefaultChannels\\";

export const postAdminTeamsSettingsSetDescription = (
  requestBody: {
    /** The new description for the workspace. */
    description: string;
    /** ID for the workspace to set the description for. */
    team_id: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminTeamsSettingsSetDescription.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT8,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postAdminTeamsSettingsSetDescription.key =
  \\"/admin.teams.settings.setDescription\\";

export const postAdminTeamsSettingsSetDiscoverability = (
  requestBody: {
    /**
     * This workspace's discovery setting. It must be set to one of \`open\`,
     * \`invite_only\`, \`closed\`, or \`unlisted\`.
     */
    discoverability: string;
    /** The ID of the workspace to set discoverability on. */
    team_id: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminTeamsSettingsSetDiscoverability.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT8,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postAdminTeamsSettingsSetDiscoverability.key =
  \\"/admin.teams.settings.setDiscoverability\\";

export const postAdminTeamsSettingsSetIcon = (
  requestBody: {
    /** Image URL for the icon */
    image_url: string;
    /** ID for the workspace to set the icon for. */
    team_id: string;
    /** Authentication token. Requires scope: \`admin.teams:write\` */
    token: string;
  },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminTeamsSettingsSetIcon.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT8,
    overrideConfig(_CONSTANT7, configOverride),
  );
};

/** Key is end point string without base url */
postAdminTeamsSettingsSetIcon.key = \\"/admin.teams.settings.setIcon\\";

export const postAdminTeamsSettingsSetName = (
  requestBody: {
    /** The new name of the workspace. */
    name: string;
    /** ID for the workspace to set the name for. */
    team_id: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminTeamsSettingsSetName.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT8,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postAdminTeamsSettingsSetName.key = \\"/admin.teams.settings.setName\\";

export const postAdminUsergroupsAddChannels = (
  requestBody: {
    /** Comma separated string of channel IDs. */
    channel_ids: string;
    /** ID of the IDP group to add default channels for. */
    usergroup_id: string;
    /** The workspace to add default channels in. */
    team_id?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminUsergroupsAddChannels.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT12,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postAdminUsergroupsAddChannels.key = \\"/admin.usergroups.addChannels\\";

export const postAdminUsergroupsAddTeams = (
  requestBody: {
    /**
     * A comma separated list of encoded team (workspace) IDs. Each workspace _MUST_
     * belong to the organization associated with the token.
     */
    team_ids: string;
    /** An encoded usergroup (IDP Group) ID. */
    usergroup_id: string;
    /**
     * When \`true\`, this method automatically creates new workspace accounts for the
     * IDP group members.
     */
    auto_provision?: boolean;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminUsergroupsAddTeams.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT8,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postAdminUsergroupsAddTeams.key = \\"/admin.usergroups.addTeams\\";

export const postAdminUsergroupsRemoveChannels = (
  requestBody: {
    /** Comma-separated string of channel IDs */
    channel_ids: string;
    /** ID of the IDP Group */
    usergroup_id: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminUsergroupsRemoveChannels.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT12,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postAdminUsergroupsRemoveChannels.key = \\"/admin.usergroups.removeChannels\\";

export const postAdminUsersAssign = (
  requestBody: {
    /** The ID (\`T1234\`) of the workspace. */
    team_id: string;
    /** The ID of the user to add to the workspace. */
    user_id: string;
    /** Comma separated values of channel IDs to add user in the new workspace. */
    channel_ids?: string;
    /** True if user should be added to the workspace as a guest. */
    is_restricted?: boolean;
    /** True if user should be added to the workspace as a single-channel guest. */
    is_ultra_restricted?: boolean;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminUsersAssign.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT14,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postAdminUsersAssign.key = \\"/admin.users.assign\\";

export const postAdminUsersInvite = (
  requestBody: {
    /**
     * A comma-separated list of \`channel_id\`s for this user to join. At least one
     * channel is required.
     */
    channel_ids: string;
    /** The email address of the person to invite. */
    email: string;
    /** The ID (\`T1234\`) of the workspace. */
    team_id: string;
    /** An optional message to send to the user in the invite email. */
    custom_message?: string;
    /**
     * Timestamp when guest account should be disabled. Only include this timestamp
     * if you are inviting a guest user and you want their account to expire on a
     * certain date.
     */
    guest_expiration_ts?: string;
    /** Is this user a multi-channel guest user? (default: false) */
    is_restricted?: boolean;
    /** Is this user a single channel guest user? (default: false) */
    is_ultra_restricted?: boolean;
    /** Full name of the user. */
    real_name?: string;
    /**
     * Allow this invite to be resent in the future if a user has not signed up yet.
     * (default: false)
     */
    resend?: boolean;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminUsersInvite.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT14,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postAdminUsersInvite.key = \\"/admin.users.invite\\";

export const postAdminUsersRemove = (
  requestBody: {
    /** The ID (\`T1234\`) of the workspace. */
    team_id: string;
    /** The ID of the user to remove. */
    user_id: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminUsersRemove.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT14,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postAdminUsersRemove.key = \\"/admin.users.remove\\";

export const postAdminUsersSessionInvalidate = (
  requestBody: {
    session_id: number;
    /** ID of the team that the session belongs to */
    team_id: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminUsersSessionInvalidate.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT14,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postAdminUsersSessionInvalidate.key = \\"/admin.users.session.invalidate\\";

export const postAdminUsersSessionReset = (
  requestBody: {
    /** The ID of the user to wipe sessions for */
    user_id: string;
    /** Only expire mobile sessions (default: false) */
    mobile_only?: boolean;
    /** Only expire web sessions (default: false) */
    web_only?: boolean;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminUsersSessionReset.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT14,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postAdminUsersSessionReset.key = \\"/admin.users.session.reset\\";

export const postAdminUsersSetAdmin = (
  requestBody: {
    /** The ID (\`T1234\`) of the workspace. */
    team_id: string;
    /** The ID of the user to designate as an admin. */
    user_id: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminUsersSetAdmin.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT14,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postAdminUsersSetAdmin.key = \\"/admin.users.setAdmin\\";

export const postAdminUsersSetExpiration = (
  requestBody: {
    /** Timestamp when guest account should be disabled. */
    expiration_ts: number;
    /** The ID (\`T1234\`) of the workspace. */
    team_id: string;
    /** The ID of the user to set an expiration for. */
    user_id: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminUsersSetExpiration.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT14,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postAdminUsersSetExpiration.key = \\"/admin.users.setExpiration\\";

export const postAdminUsersSetOwner = (
  requestBody: {
    /** The ID (\`T1234\`) of the workspace. */
    team_id: string;
    /** Id of the user to promote to owner. */
    user_id: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminUsersSetOwner.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT14,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postAdminUsersSetOwner.key = \\"/admin.users.setOwner\\";

export const postAdminUsersSetRegular = (
  requestBody: {
    /** The ID (\`T1234\`) of the workspace. */
    team_id: string;
    /** The ID of the user to designate as a regular user. */
    user_id: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postAdminUsersSetRegular.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT14,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postAdminUsersSetRegular.key = \\"/admin.users.setRegular\\";

export const postCallsAdd = (
  requestBody: {
    /**
     * An ID supplied by the 3rd-party Call provider. It must be unique across all
     * Calls from that service.
     */
    external_unique_id: string;
    /** The URL required for a client to join the Call. */
    join_url: string;
    /**
     * The valid Slack user ID of the user who created this Call. When this method
     * is called with a user token, the \`created_by\` field is optional and defaults
     * to the authed user of the token. Otherwise, the field is required.
     */
    created_by?: string;
    /** Call start time in UTC UNIX timestamp format */
    date_start?: number;
    /**
     * When supplied, available Slack clients will attempt to directly launch the
     * 3rd-party Call with this URL.
     */
    desktop_app_join_url?: string;
    /**
     * An optional, human-readable ID supplied by the 3rd-party Call provider. If
     * supplied, this ID will be displayed in the Call object.
     */
    external_display_id?: string;
    /** The name of the Call. */
    title?: string;
    /**
     * The list of users to register as participants in the Call. [Read more on how
     * to specify users here](/apis/calls#users).
     */
    users?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postCallsAdd.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT19,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postCallsAdd.key = \\"/calls.add\\";

export const postCallsEnd = (
  requestBody: {
    /**
     * \`id\` returned when registering the call using the
     * [\`calls.add\`](/methods/calls.add) method.
     */
    id: string;
    /** Call duration in seconds */
    duration?: number;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postCallsEnd.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT19,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postCallsEnd.key = \\"/calls.end\\";

export const postCallsParticipantsAdd = (
  requestBody: {
    /** \`id\` returned by the [\`calls.add\`](/methods/calls.add) method. */
    id: string;
    /**
     * The list of users to add as participants in the Call. [Read more on how to
     * specify users here](/apis/calls#users).
     */
    users: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postCallsParticipantsAdd.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT19,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postCallsParticipantsAdd.key = \\"/calls.participants.add\\";

export const postCallsParticipantsRemove = (
  requestBody: {
    /** \`id\` returned by the [\`calls.add\`](/methods/calls.add) method. */
    id: string;
    /**
     * The list of users to remove as participants in the Call. [Read more on how to
     * specify users here](/apis/calls#users).
     */
    users: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postCallsParticipantsRemove.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT19,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postCallsParticipantsRemove.key = \\"/calls.participants.remove\\";

export const postCallsUpdate = (
  requestBody: {
    /** \`id\` returned by the [\`calls.add\`](/methods/calls.add) method. */
    id: string;
    /**
     * When supplied, available Slack clients will attempt to directly launch the
     * 3rd-party Call with this URL.
     */
    desktop_app_join_url?: string;
    /** The URL required for a client to join the Call. */
    join_url?: string;
    /** The name of the Call. */
    title?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postCallsUpdate.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT19,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postCallsUpdate.key = \\"/calls.update\\";

export const postChatDelete = (
  requestBody: {
    /**
     * Pass true to delete the message as the authed user with \`chat:write:user\`
     * scope. [Bot users](/bot-users) in this context are considered authed users.
     * If unused or false, the message will be deleted with \`chat:write:bot\` scope.
     */
    as_user?: boolean;
    /** Channel containing the message to be deleted. */
    channel?: string;
    /** Timestamp of the message to be deleted. */
    ts?: number;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{ channel: Defs_channel; ok: Defs_ok_true; ts: Defs_ts }>
> => {
  return Http.postRequest(
    postChatDelete.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT21,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postChatDelete.key = \\"/chat.delete\\";

export const postChatDeleteScheduledMessage = (
  requestBody: {
    /** The channel the scheduled_message is posting to */
    channel: string;
    /** \`scheduled_message_id\` returned from call to chat.scheduleMessage */
    scheduled_message_id: string;
    /**
     * Pass true to delete the message as the authed user with \`chat:write:user\`
     * scope. [Bot users](/bot-users) in this context are considered authed users.
     * If unused or false, the message will be deleted with \`chat:write:bot\` scope.
     */
    as_user?: boolean;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postChatDeleteScheduledMessage.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT21,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postChatDeleteScheduledMessage.key = \\"/chat.deleteScheduledMessage\\";

export const postChatMeMessage = (
  requestBody: {
    /**
     * Channel to send message to. Can be a public channel, private group or IM
     * channel. Can be an encoded ID, or a name.
     */
    channel?: string;
    /** Text of the message to send. */
    text?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{ ok: Defs_ok_true; channel?: Defs_channel; ts?: Defs_ts }>
> => {
  return Http.postRequest(
    postChatMeMessage.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT21,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postChatMeMessage.key = \\"/chat.meMessage\\";

export const postChatPostEphemeral = (
  requestBody: {
    /**
     * Channel, private group, or IM channel to send message to. Can be an encoded
     * ID, or a name.
     */
    channel: string;
    /**
     * \`id\` of the user who will receive the ephemeral message. The user should be
     * in the channel specified by the \`channel\` argument.
     */
    user: string;
    /**
     * Pass true to post the message as the authed user. Defaults to true if the
     * chat:write:bot scope is not included. Otherwise, defaults to false.
     */
    as_user?: boolean;
    /**
     * A JSON-based array of structured attachments, presented as a URL-encoded
     * string.
     */
    attachments?: string;
    /** A JSON-based array of structured blocks, presented as a URL-encoded string. */
    blocks?: string;
    /**
     * Emoji to use as the icon for this message. Overrides \`icon_url\`. Must be used
     * in conjunction with \`as_user\` set to \`false\`, otherwise ignored. See
     * [authorship](#authorship) below.
     */
    icon_emoji?: string;
    /**
     * URL to an image to use as the icon for this message. Must be used in
     * conjunction with \`as_user\` set to false, otherwise ignored. See
     * [authorship](#authorship) below.
     */
    icon_url?: string;
    /** Find and link channel names and usernames. */
    link_names?: boolean;
    /**
     * Change how messages are treated. Defaults to \`none\`. See
     * [below](#formatting).
     */
    parse?: string;
    /**
     * How this field works and whether it is required depends on other fields you
     * use in your API call. [See below](#text_usage) for more detail.
     */
    text?: string;
    /**
     * Provide another message's \`ts\` value to post this message in a thread. Avoid
     * using a reply's \`ts\` value; use its parent's value instead. Ephemeral
     * messages in threads are only shown if there is already an active thread.
     */
    thread_ts?: string;
    /**
     * Set your bot's user name. Must be used in conjunction with \`as_user\` set to
     * false, otherwise ignored. See [authorship](#authorship) below.
     */
    username?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ message_ts: Defs_ts; ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postChatPostEphemeral.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT21,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postChatPostEphemeral.key = \\"/chat.postEphemeral\\";

export const postChatPostMessage = (
  requestBody: {
    /**
     * Channel, private group, or IM channel to send message to. Can be an encoded
     * ID, or a name. See [below](#channels) for more details.
     */
    channel: string;
    /**
     * Pass true to post the message as the authed user, instead of as a bot.
     * Defaults to false. See [authorship](#authorship) below.
     */
    as_user?: string;
    /**
     * A JSON-based array of structured attachments, presented as a URL-encoded
     * string.
     */
    attachments?: string;
    /** A JSON-based array of structured blocks, presented as a URL-encoded string. */
    blocks?: string;
    /**
     * Emoji to use as the icon for this message. Overrides \`icon_url\`. Must be used
     * in conjunction with \`as_user\` set to \`false\`, otherwise ignored. See
     * [authorship](#authorship) below.
     */
    icon_emoji?: string;
    /**
     * URL to an image to use as the icon for this message. Must be used in
     * conjunction with \`as_user\` set to false, otherwise ignored. See
     * [authorship](#authorship) below.
     */
    icon_url?: string;
    /** Find and link channel names and usernames. */
    link_names?: boolean;
    /** Disable Slack markup parsing by setting to \`false\`. Enabled by default. */
    mrkdwn?: boolean;
    /**
     * Change how messages are treated. Defaults to \`none\`. See
     * [below](#formatting).
     */
    parse?: string;
    /**
     * Used in conjunction with \`thread_ts\` and indicates whether reply should be
     * made visible to everyone in the channel or conversation. Defaults to
     * \`false\`.
     */
    reply_broadcast?: boolean;
    /**
     * How this field works and whether it is required depends on other fields you
     * use in your API call. [See below](#text_usage) for more detail.
     */
    text?: string;
    /**
     * Provide another message's \`ts\` value to make this message a reply. Avoid
     * using a reply's \`ts\` value; use its parent instead.
     */
    thread_ts?: string;
    /** Pass true to enable unfurling of primarily text-based content. */
    unfurl_links?: boolean;
    /** Pass false to disable unfurling of media content. */
    unfurl_media?: boolean;
    /**
     * Set your bot's user name. Must be used in conjunction with \`as_user\` set to
     * false, otherwise ignored. See [authorship](#authorship) below.
     */
    username?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    channel: Defs_channel;
    message: Objs_message;
    ok: Defs_ok_true;
    ts: Defs_ts;
  }>
> => {
  return Http.postRequest(
    postChatPostMessage.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT21,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postChatPostMessage.key = \\"/chat.postMessage\\";

export const postChatScheduleMessage = (
  requestBody: {
    /**
     * Pass true to post the message as the authed user, instead of as a bot.
     * Defaults to false. See [chat.postMessage](chat.postMessage#authorship).
     */
    as_user?: boolean;
    /**
     * A JSON-based array of structured attachments, presented as a URL-encoded
     * string.
     */
    attachments?: string;
    /** A JSON-based array of structured blocks, presented as a URL-encoded string. */
    blocks?: string;
    /**
     * Channel, private group, or DM channel to send message to. Can be an encoded
     * ID, or a name. See [below](#channels) for more details.
     */
    channel?: string;
    /** Find and link channel names and usernames. */
    link_names?: boolean;
    /**
     * Change how messages are treated. Defaults to \`none\`. See
     * [chat.postMessage](chat.postMessage#formatting).
     */
    parse?: string;
    /** Unix EPOCH timestamp of time in future to send the message. */
    post_at?: string;
    /**
     * Used in conjunction with \`thread_ts\` and indicates whether reply should be
     * made visible to everyone in the channel or conversation. Defaults to
     * \`false\`.
     */
    reply_broadcast?: boolean;
    /**
     * How this field works and whether it is required depends on other fields you
     * use in your API call. [See below](#text_usage) for more detail.
     */
    text?: string;
    /**
     * Provide another message's \`ts\` value to make this message a reply. Avoid
     * using a reply's \`ts\` value; use its parent instead.
     */
    thread_ts?: number;
    /** Pass true to enable unfurling of primarily text-based content. */
    unfurl_links?: boolean;
    /** Pass false to disable unfurling of media content. */
    unfurl_media?: boolean;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    channel: Defs_channel;
    message: {
      bot_id: Defs_bot_id;
      team: Defs_team;
      text: string;
      type: string;
      user: Defs_user_id;
      bot_profile?: Objs_bot_profile;
      username?: string;
    };
    ok: Defs_ok_true;
    /** - Pattern: ^\\\\d{10}$ */
    post_at: number;
    /**
     * Scheduled Message ID
     *
     * - Pattern: ^[Q][A-Z0-9]{8,}$
     */
    scheduled_message_id: string;
  }>
> => {
  return Http.postRequest(
    postChatScheduleMessage.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT21,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postChatScheduleMessage.key = \\"/chat.scheduleMessage\\";

export const postChatUnfurl = (
  requestBody: {
    /** Channel ID of the message */
    channel: string;
    /** Timestamp of the message to add unfurl behavior to. */
    ts: string;
    /**
     * URL-encoded JSON map with keys set to URLs featured in the the message,
     * pointing to their unfurl blocks or message attachments.
     */
    unfurls?: string;
    /**
     * Provide a simply-formatted string to send as an ephemeral message to the user
     * as invitation to authenticate further and enable full unfurling behavior
     */
    user_auth_message?: string;
    /**
     * Set to \`true\` or \`1\` to indicate the user must install your Slack app to
     * trigger unfurls for this domain
     */
    user_auth_required?: boolean;
    /**
     * Send users to this custom URL where they will complete authentication in your
     * app to fully trigger unfurling. Value should be properly URL-encoded.
     */
    user_auth_url?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postChatUnfurl.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT22,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postChatUnfurl.key = \\"/chat.unfurl\\";

export const postChatUpdate = (
  requestBody: {
    /** Channel containing the message to be updated. */
    channel: string;
    /** Timestamp of the message to be updated. */
    ts: string;
    /**
     * Pass true to update the message as the authed user. [Bot users](/bot-users)
     * in this context are considered authed users.
     */
    as_user?: string;
    /**
     * A JSON-based array of structured attachments, presented as a URL-encoded
     * string. This field is required when not presenting \`text\`. If you don't
     * include this field, the message's previous \`attachments\` will be retained. To
     * remove previous \`attachments\`, include an empty array for this field.
     */
    attachments?: string;
    /**
     * A JSON-based array of [structured blocks](/block-kit/building), presented as
     * a URL-encoded string. If you don't include this field, the message's previous
     * \`blocks\` will be retained. To remove previous \`blocks\`, include an empty
     * array for this field.
     */
    blocks?: string;
    /**
     * Find and link channel names and usernames. Defaults to \`none\`. If you do not
     * specify a value for this field, the original value set for the message will
     * be overwritten with the default, \`none\`.
     */
    link_names?: string;
    /**
     * Change how messages are treated. Defaults to \`client\`, unlike
     * \`chat.postMessage\`. Accepts either \`none\` or \`full\`. If you do not specify a
     * value for this field, the original value set for the message will be
     * overwritten with the default, \`client\`.
     */
    parse?: string;
    /**
     * New text for the message, using the [default formatting
     * rules](/reference/surfaces/formatting). It's not required when presenting
     * \`blocks\` or \`attachments\`.
     */
    text?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    channel: string;
    /** Message object */
    message: {
      text: string;
      attachments?: { [x in string | number]: any }[];
      blocks?: { [x in string | number]: any };
    };
    ok: Defs_ok_true;
    text: string;
    ts: string;
  }>
> => {
  return Http.postRequest(
    postChatUpdate.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT21,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postChatUpdate.key = \\"/chat.update\\";

export const postConversationsArchive = (
  requestBody: {
    /** ID of conversation to archive */
    channel?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postConversationsArchive.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT23,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postConversationsArchive.key = \\"/conversations.archive\\";

export const postConversationsClose = (
  requestBody: {
    /** Conversation to close. */
    channel?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    ok: Defs_ok_true;
    already_closed?: boolean;
    no_op?: boolean;
  }>
> => {
  return Http.postRequest(
    postConversationsClose.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT23,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postConversationsClose.key = \\"/conversations.close\\";

export const postConversationsCreate = (
  requestBody: {
    /** Create a private channel instead of a public one */
    is_private?: boolean;
    /** Name of the public or private channel to create */
    name?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{ channel: Objs_conversation; ok: Defs_ok_true }>
> => {
  return Http.postRequest(
    postConversationsCreate.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT23,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postConversationsCreate.key = \\"/conversations.create\\";

export const postConversationsInvite = (
  requestBody: {
    /** The ID of the public or private channel to invite user(s) to. */
    channel?: string;
    /** A comma separated list of user IDs. Up to 1000 users may be listed. */
    users?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{ channel: Objs_conversation; ok: Defs_ok_true }>
> => {
  return Http.postRequest(
    postConversationsInvite.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT23,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postConversationsInvite.key = \\"/conversations.invite\\";

export const postConversationsJoin = (
  requestBody: {
    /** ID of conversation to join */
    channel?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    channel: Objs_conversation;
    ok: Defs_ok_true;
    /** Response metadata */
    response_metadata?: { warnings?: string[] };
    warning?: string;
  }>
> => {
  return Http.postRequest(
    postConversationsJoin.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT26,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postConversationsJoin.key = \\"/conversations.join\\";

export const postConversationsKick = (
  requestBody: {
    /** ID of conversation to remove user from. */
    channel?: string;
    /** User ID to be removed. */
    user?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postConversationsKick.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT23,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postConversationsKick.key = \\"/conversations.kick\\";

export const postConversationsLeave = (
  requestBody: {
    /** Conversation to leave */
    channel?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true; not_in_channel?: true }>> => {
  return Http.postRequest(
    postConversationsLeave.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT23,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postConversationsLeave.key = \\"/conversations.leave\\";

export const postConversationsMark = (
  requestBody: {
    /** Channel or conversation to set the read cursor for. */
    channel?: string;
    /**
     * Unique identifier of message you want marked as most recently seen in this
     * conversation.
     */
    ts?: number;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postConversationsMark.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT23,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postConversationsMark.key = \\"/conversations.mark\\";

export const postConversationsOpen = (
  requestBody: {
    /**
     * Resume a conversation by supplying an \`im\` or \`mpim\`'s ID. Or provide the
     * \`users\` field instead.
     */
    channel?: string;
    /** Boolean, indicates you want the full IM channel definition in the response. */
    return_im?: boolean;
    /**
     * Comma separated lists of users. If only one user is included, this creates a
     * 1:1 DM. The ordering of the users is preserved whenever a multi-person direct
     * message is returned. Supply a \`channel\` when not supplying \`users\`.
     */
    users?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    channel: (
      | Objs_conversation
      | {
          id: Defs_dm_id;
          created?: string;
          is_im?: boolean;
          is_open?: boolean;
          last_read?: Defs_ts;
          latest?: Objs_message;
          unread_count?: number;
          unread_count_display?: number;
          user?: Defs_user_id;
        }
    )[];
    ok: Defs_ok_true;
    already_open?: boolean;
    no_op?: boolean;
  }>
> => {
  return Http.postRequest(
    postConversationsOpen.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT23,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postConversationsOpen.key = \\"/conversations.open\\";

export const postConversationsRename = (
  requestBody: {
    /** ID of conversation to rename */
    channel?: string;
    /** New name for conversation. */
    name?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{ channel: Objs_conversation; ok: Defs_ok_true }>
> => {
  return Http.postRequest(
    postConversationsRename.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT23,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postConversationsRename.key = \\"/conversations.rename\\";

export const postConversationsSetPurpose = (
  requestBody: {
    /** Conversation to set the purpose of */
    channel?: string;
    /** A new, specialer purpose */
    purpose?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{ channel: Objs_conversation; ok: Defs_ok_true }>
> => {
  return Http.postRequest(
    postConversationsSetPurpose.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT23,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postConversationsSetPurpose.key = \\"/conversations.setPurpose\\";

export const postConversationsSetTopic = (
  requestBody: {
    /** Conversation to set the topic of */
    channel?: string;
    /** The new topic string. Does not support formatting or linkification. */
    topic?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{ channel: Objs_conversation; ok: Defs_ok_true }>
> => {
  return Http.postRequest(
    postConversationsSetTopic.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT23,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postConversationsSetTopic.key = \\"/conversations.setTopic\\";

export const postConversationsUnarchive = (
  requestBody: {
    /** ID of conversation to unarchive */
    channel?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postConversationsUnarchive.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT23,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postConversationsUnarchive.key = \\"/conversations.unarchive\\";

export const postDndEndDnd = (
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postDndEndDnd.key,
    undefined,
    undefined,
    _CONSTANT27,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT6,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postDndEndDnd.key = \\"/dnd.endDnd\\";

export const postDndEndSnooze = (
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    dnd_enabled: boolean;
    next_dnd_end_ts: number;
    next_dnd_start_ts: number;
    ok: Defs_ok_true;
    snooze_enabled: boolean;
  }>
> => {
  return Http.postRequest(
    postDndEndSnooze.key,
    undefined,
    undefined,
    _CONSTANT27,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT6,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postDndEndSnooze.key = \\"/dnd.endSnooze\\";

export const postDndSetSnooze = (
  requestBody: {
    /** Number of minutes, from now, to snooze until. */
    num_minutes: string;
    /** Authentication token. Requires scope: \`dnd:write\` */
    token: string;
  },
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    ok: Defs_ok_true;
    snooze_enabled: boolean;
    snooze_endtime: number;
    snooze_remaining: number;
  }>
> => {
  return Http.postRequest(
    postDndSetSnooze.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT27,
    overrideConfig(_CONSTANT7, configOverride),
  );
};

/** Key is end point string without base url */
postDndSetSnooze.key = \\"/dnd.setSnooze\\";

export const postFilesCommentsDelete = (
  requestBody: {
    /** File to delete a comment from. */
    file?: string;
    /** The comment to delete. */
    id?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postFilesCommentsDelete.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT30,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postFilesCommentsDelete.key = \\"/files.comments.delete\\";

export const postFilesDelete = (
  requestBody: {
    /** ID of file to delete. */
    file?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postFilesDelete.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT30,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postFilesDelete.key = \\"/files.delete\\";

export const postFilesRemoteAdd = (
  requestBody: {
    /** Creator defined GUID for the file. */
    external_id?: string;
    /** URL of the remote file. */
    external_url?: string;
    /** Type of file */
    filetype?: string;
    /**
     * A text file (txt, pdf, doc, etc.) containing textual search terms that are
     * used to improve discovery of the remote file.
     */
    indexable_file_contents?: string;
    /** Preview of the document via \`multipart/form-data\`. */
    preview_image?: string;
    /** Title of the file being shared. */
    title?: string;
    /** Authentication token. Requires scope: \`remote_files:write\` */
    token?: string;
  },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postFilesRemoteAdd.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT32,
    overrideConfig(_CONSTANT7, configOverride),
  );
};

/** Key is end point string without base url */
postFilesRemoteAdd.key = \\"/files.remote.add\\";

export const postFilesRemoteRemove = (
  requestBody: {
    /** Creator defined GUID for the file. */
    external_id?: string;
    /** Specify a file by providing its ID. */
    file?: string;
    /** Authentication token. Requires scope: \`remote_files:write\` */
    token?: string;
  },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postFilesRemoteRemove.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT32,
    overrideConfig(_CONSTANT7, configOverride),
  );
};

/** Key is end point string without base url */
postFilesRemoteRemove.key = \\"/files.remote.remove\\";

export const postFilesRemoteUpdate = (
  requestBody: {
    /** Creator defined GUID for the file. */
    external_id?: string;
    /** URL of the remote file. */
    external_url?: string;
    /** Specify a file by providing its ID. */
    file?: string;
    /** Type of file */
    filetype?: string;
    /**
     * File containing contents that can be used to improve searchability for the
     * remote file.
     */
    indexable_file_contents?: string;
    /** Preview of the document via \`multipart/form-data\`. */
    preview_image?: string;
    /** Title of the file being shared. */
    title?: string;
    /** Authentication token. Requires scope: \`remote_files:write\` */
    token?: string;
  },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postFilesRemoteUpdate.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT32,
    overrideConfig(_CONSTANT7, configOverride),
  );
};

/** Key is end point string without base url */
postFilesRemoteUpdate.key = \\"/files.remote.update\\";

export const postFilesRevokePublicURL = (
  requestBody: {
    /** File to revoke */
    file?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ file: Objs_file; ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postFilesRevokePublicURL.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT30,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postFilesRevokePublicURL.key = \\"/files.revokePublicURL\\";

export const postFilesSharedPublicURL = (
  requestBody: {
    /** File to share */
    file?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ file: Objs_file; ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postFilesSharedPublicURL.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT30,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postFilesSharedPublicURL.key = \\"/files.sharedPublicURL\\";

export const postFilesUpload = (
  requestBody: {
    /** Comma-separated list of channel names or IDs where the file will be shared. */
    channels?: string;
    /**
     * File contents via a POST variable. If omitting this parameter, you must
     * provide a \`file\`.
     */
    content?: string;
    /**
     * File contents via \`multipart/form-data\`. If omitting this parameter, you must
     * submit \`content\`.
     */
    file?: string;
    /** Filename of file. */
    filename?: string;
    /** A [file type](/types/file#file_types) identifier. */
    filetype?: string;
    /** The message text introducing the file in specified \`channels\`. */
    initial_comment?: string;
    /**
     * Provide another message's \`ts\` value to upload this file as a reply. Never
     * use a reply's \`ts\` value; use its parent instead.
     */
    thread_ts?: number;
    /** Title of file. */
    title?: string;
    /** Authentication token. Requires scope: \`files:write:user\` */
    token?: string;
  },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ file: Objs_file; ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postFilesUpload.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT30,
    overrideConfig(_CONSTANT7, configOverride),
  );
};

/** Key is end point string without base url */
postFilesUpload.key = \\"/files.upload\\";

export const postPinsAdd = (
  requestBody: {
    /** Channel to pin the item in. */
    channel: string;
    /** Timestamp of the message to pin. */
    timestamp?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postPinsAdd.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT36,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postPinsAdd.key = \\"/pins.add\\";

export const postPinsRemove = (
  requestBody: {
    /** Channel where the item is pinned to. */
    channel: string;
    /** Timestamp of the message to un-pin. */
    timestamp?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postPinsRemove.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT36,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postPinsRemove.key = \\"/pins.remove\\";

export const postReactionsAdd = (
  requestBody: {
    /** Channel where the message to add reaction to was posted. */
    channel: string;
    /** Reaction (emoji) name. */
    name: string;
    /** Timestamp of the message to add reaction to. */
    timestamp: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postReactionsAdd.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT38,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postReactionsAdd.key = \\"/reactions.add\\";

export const postReactionsRemove = (
  requestBody: {
    /** Reaction (emoji) name. */
    name: string;
    /** Channel where the message to remove reaction from was posted. */
    channel?: string;
    /** File to remove reaction from. */
    file?: string;
    /** File comment to remove reaction from. */
    file_comment?: string;
    /** Timestamp of the message to remove reaction from. */
    timestamp?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postReactionsRemove.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT38,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postReactionsRemove.key = \\"/reactions.remove\\";

export const postRemindersAdd = (
  requestBody: {
    /** The content of the reminder */
    text: string;
    /**
     * When this reminder should happen: the Unix timestamp (up to five years from
     * now), the number of seconds until the reminder (if within 24 hours), or a
     * natural language description (Ex. \\"in 15 minutes,\\" or \\"every Thursday\\")
     */
    time: string;
    /**
     * The user who will receive the reminder. If no user is specified, the reminder
     * will go to user who created it.
     */
    user?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true; reminder: Objs_reminder }>> => {
  return Http.postRequest(
    postRemindersAdd.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT40,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postRemindersAdd.key = \\"/reminders.add\\";

export const postRemindersComplete = (
  requestBody: {
    /** The ID of the reminder to be marked as complete */
    reminder?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postRemindersComplete.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT40,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postRemindersComplete.key = \\"/reminders.complete\\";

export const postRemindersDelete = (
  requestBody: {
    /** The ID of the reminder */
    reminder?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postRemindersDelete.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT40,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postRemindersDelete.key = \\"/reminders.delete\\";

export const postStarsAdd = (
  requestBody: {
    /**
     * Channel to add star to, or channel where the message to add star to was
     * posted (used with \`timestamp\`).
     */
    channel?: string;
    /** File to add star to. */
    file?: string;
    /** File comment to add star to. */
    file_comment?: string;
    /** Timestamp of the message to add star to. */
    timestamp?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postStarsAdd.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT44,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postStarsAdd.key = \\"/stars.add\\";

export const postStarsRemove = (
  requestBody: {
    /**
     * Channel to remove star from, or channel where the message to remove star from
     * was posted (used with \`timestamp\`).
     */
    channel?: string;
    /** File to remove star from. */
    file?: string;
    /** File comment to remove star from. */
    file_comment?: string;
    /** Timestamp of the message to remove star from. */
    timestamp?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postStarsRemove.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT44,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postStarsRemove.key = \\"/stars.remove\\";

export const postUsergroupsCreate = (
  requestBody: {
    /** A name for the User Group. Must be unique among User Groups. */
    name: string;
    /**
     * A comma separated string of encoded channel IDs for which the User Group uses
     * as a default.
     */
    channels?: string;
    /** A short description of the User Group. */
    description?: string;
    /** A mention handle. Must be unique among channels, users and User Groups. */
    handle?: string;
    /** Include the number of users in each User Group. */
    include_count?: boolean;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true; usergroup: Objs_subteam }>> => {
  return Http.postRequest(
    postUsergroupsCreate.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT49,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postUsergroupsCreate.key = \\"/usergroups.create\\";

export const postUsergroupsDisable = (
  requestBody: {
    /** The encoded ID of the User Group to disable. */
    usergroup: string;
    /** Include the number of users in the User Group. */
    include_count?: boolean;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true; usergroup: Objs_subteam }>> => {
  return Http.postRequest(
    postUsergroupsDisable.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT49,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postUsergroupsDisable.key = \\"/usergroups.disable\\";

export const postUsergroupsEnable = (
  requestBody: {
    /** The encoded ID of the User Group to enable. */
    usergroup: string;
    /** Include the number of users in the User Group. */
    include_count?: boolean;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true; usergroup: Objs_subteam }>> => {
  return Http.postRequest(
    postUsergroupsEnable.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT49,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postUsergroupsEnable.key = \\"/usergroups.enable\\";

export const postUsergroupsUpdate = (
  requestBody: {
    /** The encoded ID of the User Group to update. */
    usergroup: string;
    /**
     * A comma separated string of encoded channel IDs for which the User Group uses
     * as a default.
     */
    channels?: string;
    /** A short description of the User Group. */
    description?: string;
    /** A mention handle. Must be unique among channels, users and User Groups. */
    handle?: string;
    /** Include the number of users in the User Group. */
    include_count?: boolean;
    /** A name for the User Group. Must be unique among User Groups. */
    name?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true; usergroup: Objs_subteam }>> => {
  return Http.postRequest(
    postUsergroupsUpdate.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT49,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postUsergroupsUpdate.key = \\"/usergroups.update\\";

export const postUsergroupsUsersUpdate = (
  requestBody: {
    /** The encoded ID of the User Group to update. */
    usergroup: string;
    /**
     * A comma separated string of encoded user IDs that represent the entire list
     * of users for the User Group.
     */
    users: string;
    /** Include the number of users in the User Group. */
    include_count?: boolean;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true; usergroup: Objs_subteam }>> => {
  return Http.postRequest(
    postUsergroupsUsersUpdate.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT49,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postUsergroupsUsersUpdate.key = \\"/usergroups.users.update\\";

export const postUsersDeletePhoto = (
  requestBody: {
    /** Authentication token. Requires scope: \`users.profile:write\` */
    token: string;
  },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postUsersDeletePhoto.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT51,
    overrideConfig(_CONSTANT7, configOverride),
  );
};

/** Key is end point string without base url */
postUsersDeletePhoto.key = \\"/users.deletePhoto\\";

export const postUsersProfileSet = (
  requestBody: {
    /** Name of a single key to set. Usable only if \`profile\` is not passed. */
    name?: string;
    /**
     * Collection of key:value pairs presented as a URL-encoded JSON hash. At most
     * 50 fields may be set. Each field name is limited to 255 characters.
     */
    profile?: string;
    /**
     * ID of user to change. This argument may only be specified by team admins on
     * paid teams.
     */
    user?: string;
    /** Value to set a single key to. Usable only if \`profile\` is not passed. */
    value?: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    ok: Defs_ok_true;
    profile: Objs_user_profile;
    username: string;
    /** - Format: email */
    email_pending?: string;
  }>
> => {
  return Http.postRequest(
    postUsersProfileSet.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT51,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postUsersProfileSet.key = \\"/users.profile.set\\";

export const postUsersSetActive = (
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postUsersSetActive.key,
    undefined,
    undefined,
    _CONSTANT54,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT6,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postUsersSetActive.key = \\"/users.setActive\\";

export const postUsersSetPhoto = (
  requestBody: {
    /** Authentication token. Requires scope: \`users.profile:write\` */
    token: string;
    /** Width/height of crop box (always square) */
    crop_w?: string;
    /** X coordinate of top-left corner of crop box */
    crop_x?: string;
    /** Y coordinate of top-left corner of crop box */
    crop_y?: string;
    /** File contents via \`multipart/form-data\`. */
    image?: string;
  },
  configOverride?: AxiosRequestConfig,
): Promise<
  SwaggerResponse<{
    ok: Defs_ok_true;
    profile: {
      /** - Pattern: ^[0-9a-f]{12}$ */
      avatar_hash: string;
      /** - Format: uri */
      image_1024: string;
      /** - Format: uri */
      image_192: string;
      /** - Format: uri */
      image_24: string;
      /** - Format: uri */
      image_32: string;
      /** - Format: uri */
      image_48: string;
      /** - Format: uri */
      image_512: string;
      /** - Format: uri */
      image_72: string;
      /** - Format: uri */
      image_original: string;
    };
  }>
> => {
  return Http.postRequest(
    postUsersSetPhoto.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT51,
    overrideConfig(_CONSTANT7, configOverride),
  );
};

/** Key is end point string without base url */
postUsersSetPhoto.key = \\"/users.setPhoto\\";

export const postUsersSetPresence = (
  requestBody: {
    /** Either \`auto\` or \`away\` */
    presence: string;
  },
  headerParams?: { token: string },
  configOverride?: AxiosRequestConfig,
): Promise<SwaggerResponse<{ ok: Defs_ok_true }>> => {
  return Http.postRequest(
    postUsersSetPresence.key,
    undefined,
    objToUrlencoded(requestBody),
    _CONSTANT54,
    overrideConfig(
      {
        headers: {
          ..._CONSTANT1,
          ...headerParams,
        },
      },
      configOverride,
    ),
  );
};

/** Key is end point string without base url */
postUsersSetPresence.key = \\"/users.setPresence\\";
export const _CONSTANT0 = [{ slackAuth: [\\"admin.apps:write\\"] }];
export const _CONSTANT1 = {
  \\"Content-Type\\": \\"application/x-www-form-urlencoded\\",
  Accept: \\"application/json\\",
};
export const _CONSTANT10 = [{ slackAuth: [\\"admin.invites:write\\"] }];
export const _CONSTANT11 = [{ slackAuth: [\\"admin.invites:read\\"] }];
export const _CONSTANT12 = [{ slackAuth: [\\"admin.usergroups:write\\"] }];
export const _CONSTANT13 = [{ slackAuth: [\\"admin.usergroups:read\\"] }];
export const _CONSTANT14 = [{ slackAuth: [\\"admin.users:write\\"] }];
export const _CONSTANT15 = [{ slackAuth: [\\"admin.users:read\\"] }];
export const _CONSTANT16 = [{ slackAuth: [\\"none\\"] }];
export const _CONSTANT17 = [{ slackAuth: [\\"authorizations:read\\"] }];
export const _CONSTANT18 = [{ slackAuth: [\\"users:read\\"] }];
export const _CONSTANT19 = [{ slackAuth: [\\"calls:write\\"] }];
export const _CONSTANT2 = [{ slackAuth: [\\"admin.apps:read\\"] }];
export const _CONSTANT20 = [{ slackAuth: [\\"calls:read\\"] }];
export const _CONSTANT21 = [
  { slackAuth: [\\"chat:write:user\\", \\"chat:write:bot\\"] },
];
export const _CONSTANT22 = [{ slackAuth: [\\"links:write\\"] }];
export const _CONSTANT23 = [
  { slackAuth: [\\"channels:write\\", \\"groups:write\\", \\"im:write\\", \\"mpim:write\\"] },
];
export const _CONSTANT24 = [
  {
    slackAuth: [
      \\"channels:history\\",
      \\"groups:history\\",
      \\"im:history\\",
      \\"mpim:history\\",
    ],
  },
];
export const _CONSTANT25 = [
  { slackAuth: [\\"channels:read\\", \\"groups:read\\", \\"im:read\\", \\"mpim:read\\"] },
];
export const _CONSTANT26 = [{ slackAuth: [\\"channels:write\\"] }];
export const _CONSTANT27 = [{ slackAuth: [\\"dnd:write\\"] }];
export const _CONSTANT28 = [{ slackAuth: [\\"dnd:read\\"] }];
export const _CONSTANT29 = [{ slackAuth: [\\"emoji:read\\"] }];
export const _CONSTANT3 = {
  headers: {
    \\"Content-Type\\": \\"application/json\\",
    Accept: \\"application/json\\",
  },
};
export const _CONSTANT30 = [{ slackAuth: [\\"files:write:user\\"] }];
export const _CONSTANT31 = [{ slackAuth: [\\"files:read\\"] }];
export const _CONSTANT32 = [{ slackAuth: [\\"remote_files:write\\"] }];
export const _CONSTANT33 = [{ slackAuth: [\\"remote_files:read\\"] }];
export const _CONSTANT34 = [{ slackAuth: [\\"remote_files:share\\"] }];
export const _CONSTANT35 = [{ slackAuth: [\\"tokens.basic\\"] }];
export const _CONSTANT36 = [{ slackAuth: [\\"pins:write\\"] }];
export const _CONSTANT37 = [{ slackAuth: [\\"pins:read\\"] }];
export const _CONSTANT38 = [{ slackAuth: [\\"reactions:write\\"] }];
export const _CONSTANT39 = [{ slackAuth: [\\"reactions:read\\"] }];
export const _CONSTANT4 = [{ slackAuth: [\\"admin.conversations:write\\"] }];
export const _CONSTANT40 = [{ slackAuth: [\\"reminders:write\\"] }];
export const _CONSTANT41 = [{ slackAuth: [\\"reminders:read\\"] }];
export const _CONSTANT42 = [{ slackAuth: [\\"rtm:stream\\"] }];
export const _CONSTANT43 = [{ slackAuth: [\\"search:read\\"] }];
export const _CONSTANT44 = [{ slackAuth: [\\"stars:write\\"] }];
export const _CONSTANT45 = [{ slackAuth: [\\"stars:read\\"] }];
export const _CONSTANT46 = [{ slackAuth: [\\"admin\\"] }];
export const _CONSTANT47 = [{ slackAuth: [\\"team:read\\"] }];
export const _CONSTANT48 = [{ slackAuth: [\\"users.profile:read\\"] }];
export const _CONSTANT49 = [{ slackAuth: [\\"usergroups:write\\"] }];
export const _CONSTANT5 = [{ slackAuth: [\\"admin.conversations:read\\"] }];
export const _CONSTANT50 = [{ slackAuth: [\\"usergroups:read\\"] }];
export const _CONSTANT51 = [{ slackAuth: [\\"users.profile:write\\"] }];
export const _CONSTANT52 = [{ slackAuth: [\\"identity.basic\\"] }];
export const _CONSTANT53 = [{ slackAuth: [\\"users:read.email\\"] }];
export const _CONSTANT54 = [{ slackAuth: [\\"users:write\\"] }];
export const _CONSTANT55 = [{ slackAuth: [\\"workflow.steps:execute\\"] }];
export const _CONSTANT6 = {
  \\"Content-Type\\": \\"application/json\\",
  Accept: \\"application/json\\",
};
export const _CONSTANT7 = {
  headers: {
    \\"Content-Type\\": \\"application/x-www-form-urlencoded\\",
    Accept: \\"application/json\\",
  },
};
export const _CONSTANT8 = [{ slackAuth: [\\"admin.teams:write\\"] }];
export const _CONSTANT9 = [{ slackAuth: [\\"admin.teams:read\\"] }];
",
  "types.ts": "//@ts-nocheck
/**
 * AUTO_GENERATED Do not change this file directly, use config.ts file instead
 *
 * @version 6
 */

export interface GetAdminAppsApprovedListQueryParams {
  /** Authentication token. Requires scope: \`admin.apps:read\` */
  token: string;
  /**
   * Set \`cursor\` to \`next_cursor\` returned by the previous call to list items in
   * the next page
   */
  cursor?: string;
  enterprise_id?: string;
  /**
   * The maximum number of items to return. Must be between 1 - 1000 both
   * inclusive.
   */
  limit?: number;
  team_id?: string;
}

export interface GetAdminAppsRequestsListQueryParams {
  /** Authentication token. Requires scope: \`admin.apps:read\` */
  token: string;
  /**
   * Set \`cursor\` to \`next_cursor\` returned by the previous call to list items in
   * the next page
   */
  cursor?: string;
  /**
   * The maximum number of items to return. Must be between 1 - 1000 both
   * inclusive.
   */
  limit?: number;
  team_id?: string;
}

export interface GetAdminAppsRestrictedListQueryParams {
  /** Authentication token. Requires scope: \`admin.apps:read\` */
  token: string;
  /**
   * Set \`cursor\` to \`next_cursor\` returned by the previous call to list items in
   * the next page
   */
  cursor?: string;
  enterprise_id?: string;
  /**
   * The maximum number of items to return. Must be between 1 - 1000 both
   * inclusive.
   */
  limit?: number;
  team_id?: string;
}

export interface GetAdminConversationsEkmListOriginalConnectedChannelInfoQueryParams {
  /** Authentication token. Requires scope: \`admin.conversations:read\` */
  token: string;
  /** A comma-separated list of channels to filter to. */
  channel_ids?: string;
  /**
   * Set \`cursor\` to \`next_cursor\` returned by the previous call to list items in
   * the next page.
   */
  cursor?: string;
  /**
   * The maximum number of items to return. Must be between 1 - 1000 both
   * inclusive.
   */
  limit?: number;
  /**
   * A comma-separated list of the workspaces to which the channels you would like
   * returned belong.
   */
  team_ids?: string;
}

export interface GetAdminConversationsGetConversationPrefsQueryParams {
  /** The channel to get preferences for. */
  channel_id: string;
}

export interface GetAdminConversationsGetTeamsQueryParams {
  /** The channel to determine connected workspaces within the organization for. */
  channel_id: string;
  /**
   * Set \`cursor\` to \`next_cursor\` returned by the previous call to list items in
   * the next page
   */
  cursor?: string;
  /**
   * The maximum number of items to return. Must be between 1 - 1000 both
   * inclusive.
   */
  limit?: number;
}

export interface GetAdminConversationsRestrictAccessListGroupsQueryParams {
  channel_id: string;
  /** Authentication token. Requires scope: \`admin.conversations:read\` */
  token: string;
  /**
   * The workspace where the channel exists. This argument is required for
   * channels only tied to one workspace, and optional for channels that are
   * shared across an organization.
   */
  team_id?: string;
}

export interface GetAdminConversationsSearchQueryParams {
  /**
   * Set \`cursor\` to \`next_cursor\` returned by the previous call to list items in
   * the next page.
   */
  cursor?: string;
  /**
   * Maximum number of items to be returned. Must be between 1 - 20 both
   * inclusive. Default is 10.
   */
  limit?: number;
  /** Name of the the channel to query by. */
  query?: string;
  /**
   * The type of channel to include or exclude in the search. For example
   * \`private\` will search private channels, while \`private_exclude\` will exclude
   * them. For a full list of types, check the [Types section](#types).
   */
  search_channel_types?: string;
  /**
   * Possible values are \`relevant\` (search ranking based on what we think is
   * closest), \`name\` (alphabetical), \`member_count\` (number of users in the
   * channel), and \`created\` (date channel was created). You can optionally pair
   * this with the \`sort_dir\` arg to change how it is sorted
   */
  sort?: string;
  /**
   * Sort direction. Possible values are \`asc\` for ascending order like (1, 2, 3)
   * or (a, b, c), and \`desc\` for descending order like (3, 2, 1) or (c, b, a)
   */
  sort_dir?: string;
  /**
   * Comma separated string of team IDs, signifying the workspaces to search
   * through.
   */
  team_ids?: string;
}

export interface GetAdminEmojiListQueryParams {
  /** Authentication token. Requires scope: \`admin.teams:read\` */
  token: string;
  /**
   * Set \`cursor\` to \`next_cursor\` returned by the previous call to list items in
   * the next page
   */
  cursor?: string;
  /**
   * The maximum number of items to return. Must be between 1 - 1000 both
   * inclusive.
   */
  limit?: number;
}

export interface GetAdminInviteRequestsApprovedListQueryParams {
  /** Value of the \`next_cursor\` field sent as part of the previous API response */
  cursor?: string;
  /**
   * The number of results that will be returned by the API on each invocation.
   * Must be between 1 - 1000, both inclusive
   */
  limit?: number;
  /** ID for the workspace where the invite requests were made. */
  team_id?: string;
}

export interface GetAdminInviteRequestsDeniedListQueryParams {
  /** Value of the \`next_cursor\` field sent as part of the previous api response */
  cursor?: string;
  /**
   * The number of results that will be returned by the API on each invocation.
   * Must be between 1 - 1000 both inclusive
   */
  limit?: number;
  /** ID for the workspace where the invite requests were made. */
  team_id?: string;
}

export interface GetAdminInviteRequestsListQueryParams {
  /** Value of the \`next_cursor\` field sent as part of the previous API response */
  cursor?: string;
  /**
   * The number of results that will be returned by the API on each invocation.
   * Must be between 1 - 1000, both inclusive
   */
  limit?: number;
  /** ID for the workspace where the invite requests were made. */
  team_id?: string;
}

export interface GetAdminTeamsAdminsListQueryParams {
  team_id: string;
  /** Authentication token. Requires scope: \`admin.teams:read\` */
  token: string;
  /**
   * Set \`cursor\` to \`next_cursor\` returned by the previous call to list items in
   * the next page.
   */
  cursor?: string;
  /** The maximum number of items to return. */
  limit?: number;
}

export interface GetAdminTeamsListQueryParams {
  /**
   * Set \`cursor\` to \`next_cursor\` returned by the previous call to list items in
   * the next page.
   */
  cursor?: string;
  /**
   * The maximum number of items to return. Must be between 1 - 100 both
   * inclusive.
   */
  limit?: number;
}

export interface GetAdminTeamsOwnersListQueryParams {
  team_id: string;
  /** Authentication token. Requires scope: \`admin.teams:read\` */
  token: string;
  /**
   * Set \`cursor\` to \`next_cursor\` returned by the previous call to list items in
   * the next page.
   */
  cursor?: string;
  /**
   * The maximum number of items to return. Must be between 1 - 1000 both
   * inclusive.
   */
  limit?: number;
}

export interface GetAdminTeamsSettingsInfoQueryParams {
  team_id: string;
}

export interface GetAdminUsergroupsListChannelsQueryParams {
  /** ID of the IDP group to list default channels for. */
  usergroup_id: string;
  /** Flag to include or exclude the count of members per channel. */
  include_num_members?: boolean;
  /** ID of the the workspace. */
  team_id?: string;
}

export interface GetAdminUsersListQueryParams {
  /** The ID (\`T1234\`) of the workspace. */
  team_id: string;
  /**
   * Set \`cursor\` to \`next_cursor\` returned by the previous call to list items in
   * the next page.
   */
  cursor?: string;
  /** Limit for how many users to be retrieved per page */
  limit?: number;
}

export interface GetApiTestQueryParams {
  /** Error response to return */
  error?: string;
  /** Example property to return */
  foo?: string;
}

export interface GetAppsEventAuthorizationsListQueryParams {
  event_context: string;
  cursor?: string;
  limit?: number;
}

export interface GetAppsPermissionsInfoQueryParams {
  /** Authentication token. Requires scope: \`none\` */
  token?: string;
}

export interface GetAppsPermissionsRequestQueryParams {
  /** A comma separated list of scopes to request for */
  scopes: string;
  /** Authentication token. Requires scope: \`none\` */
  token: string;
  /** Token used to trigger the permissions API */
  trigger_id: string;
}

export interface GetAppsPermissionsResourcesListQueryParams {
  /** Authentication token. Requires scope: \`none\` */
  token: string;
  /**
   * Paginate through collections of data by setting the \`cursor\` parameter to a
   * \`next_cursor\` attribute returned by a previous request's \`response_metadata\`.
   * Default value fetches the first \\"page\\" of the collection. See
   * [pagination](/docs/pagination) for more detail.
   */
  cursor?: string;
  /** The maximum number of items to return. */
  limit?: number;
}

export interface GetAppsPermissionsScopesListQueryParams {
  /** Authentication token. Requires scope: \`none\` */
  token: string;
}

export interface GetAppsPermissionsUsersListQueryParams {
  /** Authentication token. Requires scope: \`none\` */
  token: string;
  /**
   * Paginate through collections of data by setting the \`cursor\` parameter to a
   * \`next_cursor\` attribute returned by a previous request's \`response_metadata\`.
   * Default value fetches the first \\"page\\" of the collection. See
   * [pagination](/docs/pagination) for more detail.
   */
  cursor?: string;
  /** The maximum number of items to return. */
  limit?: number;
}

export interface GetAppsPermissionsUsersRequestQueryParams {
  /** A comma separated list of user scopes to request for */
  scopes: string;
  /** Authentication token. Requires scope: \`none\` */
  token: string;
  /** Token used to trigger the request */
  trigger_id: string;
  /** The user this scope is being requested for */
  user: string;
}

export interface GetAppsUninstallQueryParams {
  /** Issued when you created your application. */
  client_id?: string;
  /** Issued when you created your application. */
  client_secret?: string;
  /** Authentication token. Requires scope: \`none\` */
  token?: string;
}

export interface GetAuthRevokeQueryParams {
  /** Authentication token. Requires scope: \`none\` */
  token: string;
  /**
   * Setting this parameter to \`1\` triggers a _testing mode_ where the specified
   * token will not actually be revoked.
   */
  test?: boolean;
}

export interface GetBotsInfoQueryParams {
  /** Authentication token. Requires scope: \`users:read\` */
  token: string;
  /** Bot user to get info on */
  bot?: string;
}

export interface GetCallsInfoQueryParams {
  /** \`id\` of the Call returned by the [\`calls.add\`](/methods/calls.add) method. */
  id: string;
}

export interface GetChatGetPermalinkQueryParams {
  /** The ID of the conversation or channel containing the message */
  channel: string;
  /** A message's \`ts\` value, uniquely identifying it within a channel */
  message_ts: string;
  /** Authentication token. Requires scope: \`none\` */
  token: string;
}

export interface GetChatScheduledMessagesListQueryParams {
  /** The channel of the scheduled messages */
  channel?: string;
  /**
   * For pagination purposes, this is the \`cursor\` value returned from a previous
   * call to \`chat.scheduledmessages.list\` indicating where you want to start this
   * call from.
   */
  cursor?: string;
  /** A UNIX timestamp of the latest value in the time range */
  latest?: number;
  /** Maximum number of original entries to return. */
  limit?: number;
  /** A UNIX timestamp of the oldest value in the time range */
  oldest?: number;
}

export interface GetConversationsHistoryQueryParams {
  /** Conversation ID to fetch history for. */
  channel?: string;
  /**
   * Paginate through collections of data by setting the \`cursor\` parameter to a
   * \`next_cursor\` attribute returned by a previous request's \`response_metadata\`.
   * Default value fetches the first \\"page\\" of the collection. See
   * [pagination](/docs/pagination) for more detail.
   */
  cursor?: string;
  /**
   * Include messages with latest or oldest timestamp in results only when either
   * timestamp is specified.
   */
  inclusive?: boolean;
  /** End of time range of messages to include in results. */
  latest?: number;
  /**
   * The maximum number of items to return. Fewer than the requested number of
   * items may be returned, even if the end of the users list hasn't been
   * reached.
   */
  limit?: number;
  /** Start of time range of messages to include in results. */
  oldest?: number;
  /** Authentication token. Requires scope: \`conversations:history\` */
  token?: string;
}

export interface GetConversationsInfoQueryParams {
  /** Conversation ID to learn more about */
  channel?: string;
  /**
   * Set this to \`true\` to receive the locale for this conversation. Defaults to
   * \`false\`
   */
  include_locale?: boolean;
  /**
   * Set to \`true\` to include the member count for the specified conversation.
   * Defaults to \`false\`
   */
  include_num_members?: boolean;
  /** Authentication token. Requires scope: \`conversations:read\` */
  token?: string;
}

export interface GetConversationsListQueryParams {
  /**
   * Paginate through collections of data by setting the \`cursor\` parameter to a
   * \`next_cursor\` attribute returned by a previous request's \`response_metadata\`.
   * Default value fetches the first \\"page\\" of the collection. See
   * [pagination](/docs/pagination) for more detail.
   */
  cursor?: string;
  /** Set to \`true\` to exclude archived channels from the list */
  exclude_archived?: boolean;
  /**
   * The maximum number of items to return. Fewer than the requested number of
   * items may be returned, even if the end of the list hasn't been reached. Must
   * be an integer no larger than 1000.
   */
  limit?: number;
  /** Authentication token. Requires scope: \`conversations:read\` */
  token?: string;
  /**
   * Mix and match channel types by providing a comma-separated list of any
   * combination of \`public_channel\`, \`private_channel\`, \`mpim\`, \`im\`
   */
  types?: string;
}

export interface GetConversationsMembersQueryParams {
  /** ID of the conversation to retrieve members for */
  channel?: string;
  /**
   * Paginate through collections of data by setting the \`cursor\` parameter to a
   * \`next_cursor\` attribute returned by a previous request's \`response_metadata\`.
   * Default value fetches the first \\"page\\" of the collection. See
   * [pagination](/docs/pagination) for more detail.
   */
  cursor?: string;
  /**
   * The maximum number of items to return. Fewer than the requested number of
   * items may be returned, even if the end of the users list hasn't been
   * reached.
   */
  limit?: number;
  /** Authentication token. Requires scope: \`conversations:read\` */
  token?: string;
}

export interface GetConversationsRepliesQueryParams {
  /** Conversation ID to fetch thread from. */
  channel?: string;
  /**
   * Paginate through collections of data by setting the \`cursor\` parameter to a
   * \`next_cursor\` attribute returned by a previous request's \`response_metadata\`.
   * Default value fetches the first \\"page\\" of the collection. See
   * [pagination](/docs/pagination) for more detail.
   */
  cursor?: string;
  /**
   * Include messages with latest or oldest timestamp in results only when either
   * timestamp is specified.
   */
  inclusive?: boolean;
  /** End of time range of messages to include in results. */
  latest?: number;
  /**
   * The maximum number of items to return. Fewer than the requested number of
   * items may be returned, even if the end of the users list hasn't been
   * reached.
   */
  limit?: number;
  /** Start of time range of messages to include in results. */
  oldest?: number;
  /** Authentication token. Requires scope: \`conversations:history\` */
  token?: string;
  /**
   * Unique identifier of a thread's parent message. \`ts\` must be the timestamp of
   * an existing message with 0 or more replies. If there are no replies then just
   * the single message referenced by \`ts\` will return - it is just an ordinary,
   * unthreaded message.
   */
  ts?: number;
}

export interface GetDialogOpenQueryParams {
  /** The dialog definition. This must be a JSON-encoded string. */
  dialog: string;
  /** Exchange a trigger to post to the user. */
  trigger_id: string;
}

export interface GetDndInfoQueryParams {
  /** Authentication token. Requires scope: \`dnd:read\` */
  token?: string;
  /** User to fetch status for (defaults to current user) */
  user?: string;
}

export interface GetDndTeamInfoQueryParams {
  /** Authentication token. Requires scope: \`dnd:read\` */
  token?: string;
  /** Comma-separated list of users to fetch Do Not Disturb status for */
  users?: string;
}

export interface GetEmojiListQueryParams {
  /** Authentication token. Requires scope: \`emoji:read\` */
  token: string;
}

export interface GetFilesInfoQueryParams {
  count?: string;
  /**
   * Parameter for pagination. File comments are paginated for a single file. Set
   * \`cursor\` equal to the \`next_cursor\` attribute returned by the previous
   * request's \`response_metadata\`. This parameter is optional, but pagination is
   * mandatory: the default value simply fetches the first \\"page\\" of the
   * collection of comments. See [pagination](/docs/pagination) for more details.
   */
  cursor?: string;
  /** Specify a file by providing its ID. */
  file?: string;
  /**
   * The maximum number of items to return. Fewer than the requested number of
   * items may be returned, even if the end of the list hasn't been reached.
   */
  limit?: number;
  page?: string;
  /** Authentication token. Requires scope: \`files:read\` */
  token?: string;
}

export interface GetFilesListQueryParams {
  /** Filter files appearing in a specific channel, indicated by its ID. */
  channel?: string;
  count?: string;
  page?: string;
  /**
   * Show truncated file info for files hidden due to being too old, and the team
   * who owns the file being over the file limit.
   */
  show_files_hidden_by_limit?: boolean;
  /** Authentication token. Requires scope: \`files:read\` */
  token?: string;
  /** Filter files created after this timestamp (inclusive). */
  ts_from?: number;
  /** Filter files created before this timestamp (inclusive). */
  ts_to?: number;
  /**
   * Filter files by type ([see below](#file_types)). You can pass multiple values
   * in the types argument, like \`types=spaces,snippets\`.The default value is
   * \`all\`, which does not filter the list.
   */
  types?: string;
  /** Filter files created by a single user. */
  user?: string;
}

export interface GetFilesRemoteInfoQueryParams {
  /** Creator defined GUID for the file. */
  external_id?: string;
  /** Specify a file by providing its ID. */
  file?: string;
  /** Authentication token. Requires scope: \`remote_files:read\` */
  token?: string;
}

export interface GetFilesRemoteListQueryParams {
  /** Filter files appearing in a specific channel, indicated by its ID. */
  channel?: string;
  /**
   * Paginate through collections of data by setting the \`cursor\` parameter to a
   * \`next_cursor\` attribute returned by a previous request's \`response_metadata\`.
   * Default value fetches the first \\"page\\" of the collection. See
   * [pagination](/docs/pagination) for more detail.
   */
  cursor?: string;
  /** The maximum number of items to return. */
  limit?: number;
  /** Authentication token. Requires scope: \`remote_files:read\` */
  token?: string;
  /** Filter files created after this timestamp (inclusive). */
  ts_from?: number;
  /** Filter files created before this timestamp (inclusive). */
  ts_to?: number;
}

export interface GetFilesRemoteShareQueryParams {
  /** Comma-separated list of channel IDs where the file will be shared. */
  channels?: string;
  /**
   * The globally unique identifier (GUID) for the file, as set by the app
   * registering the file with Slack. Either this field or \`file\` or both are
   * required.
   */
  external_id?: string;
  /**
   * Specify a file registered with Slack by providing its ID. Either this field
   * or \`external_id\` or both are required.
   */
  file?: string;
  /** Authentication token. Requires scope: \`remote_files:share\` */
  token?: string;
}

export interface GetMigrationExchangeQueryParams {
  /** Authentication token. Requires scope: \`tokens.basic\` */
  token: string;
  /** A comma-separated list of user ids, up to 400 per request */
  users: string;
  /** Specify team_id starts with \`T\` in case of Org Token */
  team_id?: string;
  /**
   * Specify \`true\` to convert \`W\` global user IDs to workspace-specific \`U\` IDs.
   * Defaults to \`false\`.
   */
  to_old?: boolean;
}

export interface GetOauthAccessQueryParams {
  /** Issued when you created your application. */
  client_id?: string;
  /** Issued when you created your application. */
  client_secret?: string;
  /** The \`code\` param returned via the OAuth callback. */
  code?: string;
  /** This must match the originally submitted URI (if one was sent). */
  redirect_uri?: string;
  /**
   * Request the user to add your app only to a single channel. Only valid with a
   * [legacy workspace app](https://api.slack.com/legacy-workspace-apps).
   */
  single_channel?: boolean;
}

export interface GetOauthTokenQueryParams {
  /** Issued when you created your application. */
  client_id?: string;
  /** Issued when you created your application. */
  client_secret?: string;
  /** The \`code\` param returned via the OAuth callback. */
  code?: string;
  /** This must match the originally submitted URI (if one was sent). */
  redirect_uri?: string;
  /** Request the user to add your app only to a single channel. */
  single_channel?: boolean;
}

export interface GetOauthV2AccessQueryParams {
  /** The \`code\` param returned via the OAuth callback. */
  code: string;
  /** Issued when you created your application. */
  client_id?: string;
  /** Issued when you created your application. */
  client_secret?: string;
  /** This must match the originally submitted URI (if one was sent). */
  redirect_uri?: string;
}

export interface GetPinsListQueryParams {
  /** Channel to get pinned items for. */
  channel: string;
  /** Authentication token. Requires scope: \`pins:read\` */
  token: string;
}

export interface GetReactionsGetQueryParams {
  /** Authentication token. Requires scope: \`reactions:read\` */
  token: string;
  /** Channel where the message to get reactions for was posted. */
  channel?: string;
  /** File to get reactions for. */
  file?: string;
  /** File comment to get reactions for. */
  file_comment?: string;
  /** If true always return the complete reaction list. */
  full?: boolean;
  /** Timestamp of the message to get reactions for. */
  timestamp?: string;
}

export interface GetReactionsListQueryParams {
  /** Authentication token. Requires scope: \`reactions:read\` */
  token: string;
  count?: number;
  /**
   * Parameter for pagination. Set \`cursor\` equal to the \`next_cursor\` attribute
   * returned by the previous request's \`response_metadata\`. This parameter is
   * optional, but pagination is mandatory: the default value simply fetches the
   * first \\"page\\" of the collection. See [pagination](/docs/pagination) for more
   * details.
   */
  cursor?: string;
  /** If true always return the complete reaction list. */
  full?: boolean;
  /**
   * The maximum number of items to return. Fewer than the requested number of
   * items may be returned, even if the end of the list hasn't been reached.
   */
  limit?: number;
  page?: number;
  /** Show reactions made by this user. Defaults to the authed user. */
  user?: string;
}

export interface GetRemindersInfoQueryParams {
  /** The ID of the reminder */
  reminder?: string;
  /** Authentication token. Requires scope: \`reminders:read\` */
  token?: string;
}

export interface GetRemindersListQueryParams {
  /** Authentication token. Requires scope: \`reminders:read\` */
  token?: string;
}

export interface GetRtmConnectQueryParams {
  /** Authentication token. Requires scope: \`rtm:stream\` */
  token: string;
  /**
   * Batch presence deliveries via subscription. Enabling changes the shape of
   * \`presence_change\` events. See [batch
   * presence](/docs/presence-and-status#batching).
   */
  batch_presence_aware?: boolean;
  /**
   * Only deliver presence events when requested by subscription. See [presence
   * subscriptions](/docs/presence-and-status#subscriptions).
   */
  presence_sub?: boolean;
}

export interface GetSearchMessagesQueryParams {
  /** Search query. */
  query: string;
  /** Authentication token. Requires scope: \`search:read\` */
  token: string;
  /** Pass the number of results you want per \\"page\\". Maximum of \`100\`. */
  count?: number;
  /** Pass a value of \`true\` to enable query highlight markers (see below). */
  highlight?: boolean;
  page?: number;
  /** Return matches sorted by either \`score\` or \`timestamp\`. */
  sort?: string;
  /** Change sort direction to ascending (\`asc\`) or descending (\`desc\`). */
  sort_dir?: string;
}

export interface GetStarsListQueryParams {
  count?: string;
  /**
   * Parameter for pagination. Set \`cursor\` equal to the \`next_cursor\` attribute
   * returned by the previous request's \`response_metadata\`. This parameter is
   * optional, but pagination is mandatory: the default value simply fetches the
   * first \\"page\\" of the collection. See [pagination](/docs/pagination) for more
   * details.
   */
  cursor?: string;
  /**
   * The maximum number of items to return. Fewer than the requested number of
   * items may be returned, even if the end of the list hasn't been reached.
   */
  limit?: number;
  page?: string;
  /** Authentication token. Requires scope: \`stars:read\` */
  token?: string;
}

export interface GetTeamAccessLogsQueryParams {
  /** Authentication token. Requires scope: \`admin\` */
  token: string;
  /** End of time range of logs to include in results (inclusive). */
  before?: string;
  count?: string;
  page?: string;
}

export interface GetTeamBillableInfoQueryParams {
  /** Authentication token. Requires scope: \`admin\` */
  token: string;
  /** A user to retrieve the billable information for. Defaults to all users. */
  user?: string;
}

export interface GetTeamInfoQueryParams {
  /** Authentication token. Requires scope: \`team:read\` */
  token: string;
  /**
   * Team to get info on, if omitted, will return information about the current
   * team. Will only return team that the authenticated token is allowed to see
   * through external shared channels
   */
  team?: string;
}

export interface GetTeamIntegrationLogsQueryParams {
  /** Authentication token. Requires scope: \`admin\` */
  token: string;
  /** Filter logs to this Slack app. Defaults to all logs. */
  app_id?: string;
  /** Filter logs with this change type. Defaults to all logs. */
  change_type?: string;
  count?: string;
  page?: string;
  /** Filter logs to this service. Defaults to all logs. */
  service_id?: string;
  /** Filter logs generated by this user’s actions. Defaults to all logs. */
  user?: string;
}

export interface GetTeamProfileGetQueryParams {
  /** Authentication token. Requires scope: \`users.profile:read\` */
  token: string;
  /** Filter by visibility. */
  visibility?: string;
}

export interface GetUsergroupsListQueryParams {
  /** Authentication token. Requires scope: \`usergroups:read\` */
  token: string;
  /** Include the number of users in each User Group. */
  include_count?: boolean;
  /** Include disabled User Groups. */
  include_disabled?: boolean;
  /** Include the list of users for each User Group. */
  include_users?: boolean;
}

export interface GetUsergroupsUsersListQueryParams {
  /** Authentication token. Requires scope: \`usergroups:read\` */
  token: string;
  /** The encoded ID of the User Group to update. */
  usergroup: string;
  /** Allow results that involve disabled User Groups. */
  include_disabled?: boolean;
}

export interface GetUsersConversationsQueryParams {
  /**
   * Paginate through collections of data by setting the \`cursor\` parameter to a
   * \`next_cursor\` attribute returned by a previous request's \`response_metadata\`.
   * Default value fetches the first \\"page\\" of the collection. See
   * [pagination](/docs/pagination) for more detail.
   */
  cursor?: string;
  /** Set to \`true\` to exclude archived channels from the list */
  exclude_archived?: boolean;
  /**
   * The maximum number of items to return. Fewer than the requested number of
   * items may be returned, even if the end of the list hasn't been reached. Must
   * be an integer no larger than 1000.
   */
  limit?: number;
  /** Authentication token. Requires scope: \`conversations:read\` */
  token?: string;
  /**
   * Mix and match channel types by providing a comma-separated list of any
   * combination of \`public_channel\`, \`private_channel\`, \`mpim\`, \`im\`
   */
  types?: string;
  /**
   * Browse conversations by a specific user ID's membership. Non-public channels
   * are restricted to those where the calling user shares membership.
   */
  user?: string;
}

export interface GetUsersGetPresenceQueryParams {
  /** Authentication token. Requires scope: \`users:read\` */
  token: string;
  /** User to get presence info on. Defaults to the authed user. */
  user?: string;
}

export interface GetUsersIdentityQueryParams {
  /** Authentication token. Requires scope: \`identity.basic\` */
  token?: string;
}

export interface GetUsersInfoQueryParams {
  /** Authentication token. Requires scope: \`users:read\` */
  token: string;
  /** Set this to \`true\` to receive the locale for this user. Defaults to \`false\` */
  include_locale?: boolean;
  /** User to get info on */
  user?: string;
}

export interface GetUsersListQueryParams {
  /**
   * Paginate through collections of data by setting the \`cursor\` parameter to a
   * \`next_cursor\` attribute returned by a previous request's \`response_metadata\`.
   * Default value fetches the first \\"page\\" of the collection. See
   * [pagination](/docs/pagination) for more detail.
   */
  cursor?: string;
  /** Set this to \`true\` to receive the locale for users. Defaults to \`false\` */
  include_locale?: boolean;
  /**
   * The maximum number of items to return. Fewer than the requested number of
   * items may be returned, even if the end of the users list hasn't been reached.
   * Providing no \`limit\` value will result in Slack attempting to deliver you the
   * entire result set. If the collection is too large you may experience
   * \`limit_required\` or HTTP 500 errors.
   */
  limit?: number;
  /** Authentication token. Requires scope: \`users:read\` */
  token?: string;
}

export interface GetUsersLookupByEmailQueryParams {
  /** An email address belonging to a user in the workspace */
  email: string;
  /** Authentication token. Requires scope: \`users:read.email\` */
  token: string;
}

export interface GetUsersProfileGetQueryParams {
  /** Authentication token. Requires scope: \`users.profile:read\` */
  token: string;
  /** Include labels for each ID in custom profile fields */
  include_labels?: boolean;
  /** User to retrieve profile info for */
  user?: string;
}

export interface GetViewsOpenQueryParams {
  /** Exchange a trigger to post to the user. */
  trigger_id: string;
  /**
   * A [view payload](/reference/surfaces/views). This must be a JSON-encoded
   * string.
   */
  view: string;
}

export interface GetViewsPublishQueryParams {
  /** \`id\` of the user you want publish a view to. */
  user_id: string;
  /**
   * A [view payload](/reference/surfaces/views). This must be a JSON-encoded
   * string.
   */
  view: string;
  /**
   * A string that represents view state to protect against possible race
   * conditions.
   */
  hash?: string;
}

export interface GetViewsPushQueryParams {
  /** Exchange a trigger to post to the user. */
  trigger_id: string;
  /**
   * A [view payload](/reference/surfaces/views). This must be a JSON-encoded
   * string.
   */
  view: string;
}

export interface GetViewsUpdateQueryParams {
  /**
   * A unique identifier of the view set by the developer. Must be unique for all
   * views on a team. Max length of 255 characters. Either \`view_id\` or
   * \`external_id\` is required.
   */
  external_id?: string;
  /**
   * A string that represents view state to protect against possible race
   * conditions.
   */
  hash?: string;
  /**
   * A [view object](/reference/surfaces/views). This must be a JSON-encoded
   * string.
   */
  view?: string;
  /**
   * A unique identifier of the view to be updated. Either \`view_id\` or
   * \`external_id\` is required.
   */
  view_id?: string;
}

export interface GetWorkflowsStepCompletedQueryParams {
  /** Context identifier that maps to the correct workflow step execution. */
  workflow_step_execute_id: string;
  /**
   * Key-value object of outputs from your step. Keys of this object reflect the
   * configured \`key\` properties of your
   * [\`outputs\`](/reference/workflows/workflow_step#output) array from your
   * \`workflow_step\` object.
   */
  outputs?: string;
}

export interface GetWorkflowsStepFailedQueryParams {
  /**
   * A JSON-based object with a \`message\` property that should contain a human
   * readable error message.
   */
  error: string;
  /** Context identifier that maps to the correct workflow step execution. */
  workflow_step_execute_id: string;
}

export interface GetWorkflowsUpdateStepQueryParams {
  /**
   * A context identifier provided with \`view_submission\` payloads used to call
   * back to \`workflows.updateStep\`.
   */
  workflow_step_edit_id: string;
  /**
   * A JSON key-value map of inputs required from a user during configuration.
   * This is the data your app expects to receive when the workflow step starts.
   * **Please note**: the embedded variable format is set and replaced by the
   * workflow system. You cannot create custom variables that will be replaced at
   * runtime. [Read more about variables in workflow steps
   * here](/workflows/steps#variables).
   */
  inputs?: string;
  /**
   * An JSON array of output objects used during step execution. This is the data
   * your app agrees to provide when your workflow step was executed.
   */
  outputs?: string;
  /**
   * An optional field that can be used to override app image that is shown in the
   * Workflow Builder.
   */
  step_image_url?: string;
  /**
   * An optional field that can be used to override the step name that is shown in
   * the Workflow Builder.
   */
  step_name?: string;
}

export interface RequestBodyadmin_inviteRequests_approve {
  /** ID of the request to invite. */
  invite_request_id: string;
  /** ID for the workspace where the invite request was made. */
  team_id?: string;
}

/**
 * Block Kit blocks
 *
 * This is a very loose definition, in the future, we'll populate this with
 * deeper schema in this definition namespace.
 */

export type Blocks = { type: string }[];

/**
 * App ID
 *
 * - Pattern: ^A[A-Z0-9]{1,}$
 */

export type Defs_app_id = string;

/**
 * Bot User ID
 *
 * - Pattern: ^B[A-Z0-9]{8,}$
 */

export type Defs_bot_id = string;

/**
 * Channel-like conversation ID
 *
 * - Pattern: ^[CGD][A-Z0-9]{8,}$
 */

export type Defs_channel = string;

/**
 * Channel ID
 *
 * - Pattern: ^[C][A-Z0-9]{2,}$
 */

export type Defs_channel_id = string;

/** Name of a channel */

export type Defs_channel_name = string;

/**
 * File Comment ID
 *
 * - Pattern: ^Fc[A-Z0-9]{8,}$
 */

export type Defs_comment_id = string;

/**
 * Direct Message Channel ID
 *
 * - Pattern: ^[D][A-Z0-9]{8,}$
 */

export type Defs_dm_id = string;

/**
 * Enterprise ID
 *
 * - Pattern: ^[E][A-Z0-9]{8,}$
 */

export type Defs_enterprise_id = string;

/** Name of the enterprise org */

export type Defs_enterprise_name = string;

/**
 * Enterprise User ID
 *
 * - Pattern: ^[WU][A-Z0-9]{8,}$
 */

export type Defs_enterprise_user_id = string;

/**
 * File ID
 *
 * - Pattern: ^[F][A-Z0-9]{8,}$
 */

export type Defs_file_id = string;

/**
 * Private Channel ID
 *
 * - Pattern: ^[G][A-Z0-9]{8,}$
 */

export type Defs_group_id = string;

/** Default failure response */

export enum Defs_ok_false {
  false = false,
}

/** Default success response */

export enum Defs_ok_true {
  true = true,
}

/**
 * App ID or empty string
 *
 * - Pattern: ^(A[A-Z0-9]{1,})?$
 */

export type Defs_optional_app_id = string;

/** Info for a pinned item */

export type Defs_pinned_info = { [x in string | number]: any };

/**
 * Reminder ID
 *
 * - Pattern: ^Rm[A-Z0-9]{8,}$
 */

export type Defs_reminder_id = string;

/**
 * Subteam ID
 *
 * - Pattern: ^S[A-Z0-9]{2,}$
 */

export type Defs_subteam_id = string;

/**
 * Team ID
 *
 * - Pattern: ^[T][A-Z0-9]{2,}$
 */

export type Defs_team = string;

/**
 * User ID or empty string, used for topic and purpose creation
 *
 * - Pattern: ^[UW][A-Z0-9]{8,}$|^$
 */

export type Defs_topic_purpose_creator = string;

/**
 * Timestamp in format 0123456789.012345
 *
 * - Pattern: ^\\\\d{10}.\\\\d{6}$
 */

export type Defs_ts = string;

/**
 * User ID
 *
 * - Pattern: ^[UW][A-Z0-9]{2,}$
 */

export type Defs_user_id = string;

/**
 * Team or Enterprise ID
 *
 * - Pattern: ^[TE][A-Z0-9]{8,}$
 */

export type Defs_workspace_id = string;

/** Bot Profile Object */

export interface Objs_bot_profile {
  app_id: Defs_app_id;
  deleted: boolean;
  icons: {
    /** - Format: uri */
    image_36: string;
    /** - Format: uri */
    image_48: string;
    /** - Format: uri */
    image_72: string;
  };
  id: Defs_bot_id;
  name: string;
  team_id: Defs_team;
  updated: number;
}

/** Channel Object */

export interface Objs_channel {
  created: number;
  creator: Defs_user_id;
  id: Defs_channel_id;
  is_channel: boolean;
  is_mpim: boolean;
  is_org_shared: boolean;
  is_private: boolean;
  is_shared: boolean;
  members: Defs_user_id[];
  name: string;
  name_normalized: string;
  purpose: {
    creator: Defs_topic_purpose_creator;
    last_set: number;
    value: string;
  };
  topic: {
    creator: Defs_topic_purpose_creator;
    last_set: number;
    value: string;
  };
  accepted_user?: Defs_user_id;
  is_archived?: boolean;
  is_frozen?: boolean;
  is_general?: boolean;
  is_member?: boolean;
  is_moved?: number;
  is_non_threadable?: boolean;
  is_pending_ext_shared?: boolean;
  is_read_only?: boolean;
  is_thread_only?: boolean;
  last_read?: Defs_ts;
  latest?: (Objs_message | null)[];
  num_members?: number;
  pending_shared?: Defs_team[];
  previous_names?: Defs_channel_name[];
  priority?: number;
  /**
   * Field to determine whether a channel has ever been shared/disconnected in the
   * past
   */
  unlinked?: number;
  unread_count?: number;
  unread_count_display?: number;
}

/** File Comment Object */

export interface Objs_comment {
  comment: string;
  created: number;
  id: Defs_comment_id;
  is_intro: boolean;
  timestamp: number;
  user: Defs_user_id;
  is_starred?: boolean;
  num_stars?: number;
  pinned_info?: Defs_pinned_info;
  pinned_to?: Defs_channel[];
  reactions?: Objs_reaction[];
}

/** File comments object */

export type Objs_comments = any[];

export type Objs_conversation = any;

export interface Objs_enterprise_user {
  enterprise_id: Defs_enterprise_id;
  enterprise_name: Defs_enterprise_name;
  id: Defs_enterprise_user_id;
  is_admin: boolean;
  is_owner: boolean;
  teams: Defs_team[];
}

/** External Org Migrations */

export interface Objs_external_org_migrations {
  current: { date_started: number; team_id: string }[];
  date_updated: number;
}

/** File object */

export interface Objs_file {
  channels?: Defs_channel_id[];
  comments_count?: number;
  created?: number;
  date_delete?: number;
  display_as_bot?: boolean;
  editable?: boolean;
  editor?: Defs_user_id;
  external_id?: string;
  external_type?: string;
  /** - Format: uri */
  external_url?: string;
  filetype?: string;
  groups?: Defs_group_id[];
  has_rich_preview?: boolean;
  id?: Defs_file_id;
  image_exif_rotation?: number;
  ims?: Defs_dm_id[];
  is_external?: boolean;
  is_public?: boolean;
  is_starred?: boolean;
  is_tombstoned?: boolean;
  last_editor?: Defs_user_id;
  mimetype?: string;
  mode?: string;
  name?: string;
  non_owner_editable?: boolean;
  num_stars?: number;
  original_h?: number;
  original_w?: number;
  /** - Format: uri */
  permalink?: string;
  /** - Format: uri */
  permalink_public?: string;
  pinned_info?: Defs_pinned_info;
  pinned_to?: Defs_channel[];
  pretty_type?: string;
  preview?: string;
  public_url_shared?: boolean;
  reactions?: Objs_reaction[];
  shares?: { private?: null; public?: null };
  size?: number;
  source_team?: Defs_team;
  state?: string;
  /** - Format: uri */
  thumb_1024?: string;
  thumb_1024_h?: number;
  thumb_1024_w?: number;
  /** - Format: uri */
  thumb_160?: string;
  /** - Format: uri */
  thumb_360?: string;
  thumb_360_h?: number;
  thumb_360_w?: number;
  /** - Format: uri */
  thumb_480?: string;
  thumb_480_h?: number;
  thumb_480_w?: number;
  /** - Format: uri */
  thumb_64?: string;
  /** - Format: uri */
  thumb_720?: string;
  thumb_720_h?: number;
  thumb_720_w?: number;
  /** - Format: uri */
  thumb_80?: string;
  /** - Format: uri */
  thumb_800?: string;
  thumb_800_h?: number;
  thumb_800_w?: number;
  /** - Format: uri */
  thumb_960?: string;
  thumb_960_h?: number;
  thumb_960_w?: number;
  thumb_tiny?: string;
  timestamp?: number;
  title?: string;
  updated?: number;
  /** - Format: uri */
  url_private?: string;
  /** - Format: uri */
  url_private_download?: string;
  user?: string;
  user_team?: Defs_team;
  username?: string;
}

export interface Objs_icon {
  image_102?: string;
  image_132?: string;
  image_230?: string;
  image_34?: string;
  image_44?: string;
  image_68?: string;
  image_88?: string;
  image_default?: boolean;
}

/** Message object */

export interface Objs_message {
  text: string;
  ts: Defs_ts;
  type: string;
  attachments?: {
    id: number;
    fallback?: string;
    image_bytes?: number;
    image_height?: number;
    image_url?: string;
    image_width?: number;
  }[];
  blocks?: Blocks;
  bot_id?: (Defs_bot_id | null)[];
  bot_profile?: Objs_bot_profile;
  client_msg_id?: string;
  comment?: Objs_comment;
  display_as_bot?: boolean;
  file?: Objs_file;
  files?: Objs_file[];
  icons?: {
    emoji?: string;
    /** - Format: uri */
    image_64?: string;
  };
  inviter?: Defs_user_id;
  is_delayed_message?: boolean;
  is_intro?: boolean;
  is_starred?: boolean;
  last_read?: Defs_ts;
  latest_reply?: Defs_ts;
  name?: string;
  old_name?: string;
  parent_user_id?: Defs_user_id;
  /** - Format: uri */
  permalink?: string;
  pinned_to?: Defs_channel[];
  purpose?: string;
  reactions?: Objs_reaction[];
  reply_count?: number;
  reply_users?: Defs_user_id[];
  reply_users_count?: number;
  source_team?: Defs_workspace_id;
  subscribed?: boolean;
  subtype?: string;
  team?: Defs_workspace_id;
  thread_ts?: Defs_ts;
  topic?: string;
  unread_count?: number;
  upload?: boolean;
  user?: Defs_user_id;
  user_profile?: Objs_user_profile_short;
  user_team?: Defs_workspace_id;
  username?: string;
}

/** Paging object */

export interface Objs_paging {
  page: number;
  total: number;
  count?: number;
  pages?: number;
  per_page?: number;
  spill?: number;
}

export interface Objs_primary_owner {
  email: string;
  id: string;
}

/** Reaction object */

export interface Objs_reaction {
  count: number;
  name: string;
  users: Defs_user_id[];
}

export interface Objs_reminder {
  creator: Defs_user_id;
  id: Defs_reminder_id;
  recurring: boolean;
  text: string;
  user: Defs_user_id;
  complete_ts?: number;
  time?: number;
}

/** Resources in info from apps.permissions.info */

export interface Objs_resources {
  ids: (Defs_channel | Defs_team)[][];
  excluded_ids?: (Defs_channel | Defs_team)[][];
  wildcard?: boolean;
}

export type Objs_response_metadata = any;

export type Objs_scopes = string[];

/** Subteam/Usergroup Object */

export interface Objs_subteam {
  auto_provision: boolean;
  auto_type: (null | \\"owner\\" | \\"admin\\")[];
  created_by: Defs_user_id;
  date_create: number;
  date_delete: number;
  date_update: number;
  deleted_by: (null | Defs_user_id)[];
  description: string;
  enterprise_subteam_id: string;
  handle: string;
  id: Defs_subteam_id;
  is_external: boolean;
  is_subteam: boolean;
  is_usergroup: boolean;
  name: string;
  prefs: { channels: Defs_channel_id[]; groups: Defs_group_id[] };
  team_id: Defs_team;
  updated_by: Defs_user_id;
  channel_count?: number;
  user_count?: number;
  users?: Defs_user_id[];
}

/** Team Object */

export interface Objs_team {
  domain: string;
  email_domain: string;
  icon: Objs_icon;
  id: Defs_workspace_id;
  name: string;
  archived?: boolean;
  /** - Format: uri */
  avatar_base_url?: string;
  created?: number;
  date_create?: number;
  deleted?: boolean;
  description?: string;
  discoverable?: (null | string)[];
  enterprise_id?: Defs_enterprise_id;
  enterprise_name?: Defs_enterprise_name;
  external_org_migrations?: Objs_external_org_migrations;
  has_compliance_export?: boolean;
  is_assigned?: boolean;
  is_enterprise?: number;
  is_over_storage_limit?: boolean;
  limit_ts?: number;
  locale?: string;
  messages_count?: number;
  msg_edit_window_mins?: number;
  over_integrations_limit?: boolean;
  over_storage_limit?: boolean;
  pay_prod_cur?: string;
  plan?: \\"\\" | \\"std\\" | \\"plus\\" | \\"compliance\\" | \\"enterprise\\";
  primary_owner?: Objs_primary_owner;
  sso_provider?: { label?: string; name?: string; type?: string };
}

export interface Objs_team_profile_field {
  hint: string;
  /** - Pattern: ^X[a-zA-Z0-9]{9,}$ */
  id: string;
  label: string;
  ordering: number;
  type: \\"text\\" | \\"date\\" | \\"link\\" | \\"mailto\\" | \\"options_list\\" | \\"user\\";
  field_name?: string;
  is_hidden?: boolean;
  options?: (null | Objs_team_profile_field_option)[];
  possible_values?: string[];
}

export interface Objs_team_profile_field_option {
  is_custom?: boolean;
  is_multiple_entry?: boolean;
  is_protected?: boolean;
  is_scim?: boolean;
}

export type Objs_user = any;

/** User profile object */

export interface Objs_user_profile {
  avatar_hash: string;
  display_name: string;
  display_name_normalized: string;
  phone: string;
  real_name: string;
  real_name_normalized: string;
  skype: string;
  status_emoji: string;
  status_text: string;
  title: string;
  always_active?: boolean;
  api_app_id?: Defs_optional_app_id;
  bot_id?: Defs_bot_id;
  /** - Format: email */
  email?: string;
  fields?: { [x in string | number]: any }[];
  first_name?: string;
  guest_expiration_ts?: number;
  guest_invited_by?: string;
  /** - Format: uri */
  image_1024?: string;
  /** - Format: uri */
  image_192?: string;
  /** - Format: uri */
  image_24?: string;
  /** - Format: uri */
  image_32?: string;
  /** - Format: uri */
  image_48?: string;
  /** - Format: uri */
  image_512?: string;
  /** - Format: uri */
  image_72?: string;
  /** - Format: uri */
  image_original?: string;
  is_app_user?: boolean;
  is_custom_image?: boolean;
  is_restricted?: boolean;
  is_ultra_restricted?: boolean;
  last_avatar_image_hash?: string;
  last_name?: string;
  memberships_count?: number;
  name?: string;
  pronouns?: string;
  status_default_emoji?: string;
  status_default_text?: string;
  status_default_text_canonical?: string;
  status_expiration?: number;
  status_text_canonical?: string;
  team?: Defs_workspace_id;
  updated?: number;
  user_id?: string;
  username?: string;
}

export interface Objs_user_profile_short {
  avatar_hash: string;
  display_name: string;
  /** - Format: uri */
  image_72: string;
  is_restricted: boolean;
  is_ultra_restricted: boolean;
  name: string;
  real_name: string;
  team: Defs_workspace_id;
  display_name_normalized?: string;
  first_name?: string;
  real_name_normalized?: string;
}
",
}
`;

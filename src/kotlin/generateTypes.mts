import { getClassBody, getKotlinType, getRefName, getSchemaName } from "./utils.mjs";
import type { Schema, Config, TypeAST } from "../types.mjs";
import { AUTOGENERATED_COMMENT } from "./strings.mjs";
import { getJsdoc } from "../utilities/jsdoc.mjs";
import { isAscending } from "../utils.mjs";

function generateTypes(types: TypeAST[], config: Config): string {
  let code = AUTOGENERATED_COMMENT;
  try {
    code += types
      .sort(({ name }, { name: _name }) => isAscending(name, _name))
      .reduce((prev, { name: _name, schema, description }) => {
        const name = getSchemaName(_name);
        prev += `
${getJsdoc({
          ...schema,
          description: description || schema?.description,
          deprecated: schema?.deprecated
            ? schema?.["x-deprecatedMessage"] || String(schema?.deprecated)
            : undefined,
        })}
${getTypeDefinition(name, schema, config)}`;

        return prev;
      }, "");

    return code;
  } catch (error) {
    console.error({ error });
    return "";
  }
}

function getTypeDefinition(name: string, schema: Schema = {}, config: Config) {
  const {
    type,
    enum: Enum,
    "x-enumNames": enumNames,
    allOf,
    oneOf,
    items,
    $ref,
    additionalProperties,
    properties,
  } = schema;

  if (Enum) {
    return `enum ${name} {${Enum.map(
      (e, index) =>
        `${enumNames ? enumNames[index] : e}=${
          typeof e === "string" ? `"${e}"` : `${e}`
        }`,
    )}}`;
  }

  if (allOf || oneOf) {
    return `union ${name} {${getKotlinType(schema, config)}}`;
  }

  if (type === "array" && items) {
    return `type ${name} = ${getKotlinType(items, config)}[]`;
  }

  if ($ref) {
    return `type ${name} ${getRefName($ref)}`;
  }

  if (type === "object") {
    const typeObject = getClassBody(schema, config);

      return `data class ${name}(${typeObject}){}`;
  }

  if (type === "string") {
    return `union ${name} {${type}}`;
  }

  return `union ${name} {Any}`;
}

export { generateTypes };

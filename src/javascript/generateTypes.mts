import { getRefName, getSchemaName, getTsType } from "./utils.mjs";
import type { Schema, Config, TypeAST } from "../types.mjs";
import { AUTOGENERATED_COMMENT } from "./strings.mjs";
import { getJsdoc } from "../utilities/jsdoc.mjs";
import { isAscending } from "../utils.mjs";

/** Generates TypeScript type definitions from an array of type ASTs */
function generateTypes(types: TypeAST[], config: Config): string {
  let code = AUTOGENERATED_COMMENT;

  const sortedTypes = types.sort(({ name }, { name: otherName }) =>
    isAscending(name, otherName),
  );

  const schemasMap = buildSchemasMap(sortedTypes);

  for (const typeAST of sortedTypes) {
    try {
      code += generateSingleType(typeAST, config, schemasMap);
    } catch (error) {
      console.error(`Failed to generate type for "${typeAST.name}":`, error);
    }
  }

  return code;
}

/** Build a map of all schemas for discriminator resolution */
function buildSchemasMap(types: TypeAST[]): Map<string, Schema> {
  const schemasMap = new Map<string, Schema>();

  for (const { name, schema } of types) {
    if (schema) {
      schemasMap.set(getSchemaName(name), schema);
    }
  }

  return schemasMap;
}

/** Generate a single type definition with JSDoc */
function generateSingleType(
  typeAST: TypeAST,
  config: Config,
  schemasMap: Map<string, Schema>,
): string {
  const { name: typeName, schema, description } = typeAST;
  const name = getSchemaName(typeName);

  const jsdoc = getJsdoc({
    ...schema,
    description: description || schema?.description,
    deprecated: schema?.deprecated
      ? schema?.["x-deprecatedMessage"] || String(schema?.deprecated)
      : undefined,
  });

  const typeDefinition = getTypeDefinition(name, schema, config, schemasMap);

  return `
    ${jsdoc}
    ${typeDefinition}
    `;
}

/** Generate a TypeScript type definition for a given schema */
function getTypeDefinition(
  name: string,
  schema: Schema = {},
  config: Config,
  schemasMap: Map<string, Schema>,
): string {
  // Handle enums
  if (schema.enum) {
    return generateEnumDefinition(
      name,
      schema.enum,
      schema["x-enumNames"],
      config,
    );
  }

  // Handle allOf/oneOf compositions
  if (schema.allOf || schema.oneOf) {
    return `export type ${name} = ${getTsType(
      schema,
      config,
      schemasMap,
      name,
    )};`;
  }

  // Handle arrays
  if (schema.type === "array" && schema.items) {
    return `export type ${name} = (${getTsType(
      schema.items,
      config,
      schemasMap,
    )})[];`;
  }

  // Handle references
  if (schema.$ref) {
    return `export type ${name} = ${getRefName(schema.$ref)};`;
  }

  // Handle objects
  if (schema.type === "object") {
    return generateObjectType(name, schema, config, schemasMap);
  }

  // Handle primitive types
  if (schema.type === "string") {
    return `export type ${name} = string;`;
  }

  // Fallback
  return `export type ${name} = any;`;
}

/** Generate object type or interface */
function generateObjectType(
  name: string,
  schema: Schema,
  config: Config,
  schemasMap: Map<string, Schema>,
): string {
  const typeObject = getTsType(schema, config, schemasMap);
  const hasProperties = schema.additionalProperties || schema.properties;
  const hasOneOf = schema.oneOf;

  if (hasProperties && !hasOneOf) {
    return `export interface ${name} ${typeObject}`;
  }

  return `export type ${name} = ${typeObject};`;
}

/** Generate enum definition as type union or enum based on config */
function generateEnumDefinition(
  name: string,
  enumValues: string[],
  enumNames: string[] | undefined,
  config: Config,
): string {
  if (config.generateEnumAsType) {
    return generateEnumAsTypeUnion(name, enumValues);
  }

  return generateEnumAsEnum(name, enumValues, enumNames);
}

/** Generate enum as a type union */
function generateEnumAsTypeUnion(name: string, enumValues: string[]): string {
  const unionString = enumValues.length
    ? enumValues.map((value) => JSON.stringify(value)).join(" | ")
    : "unknown";

  return `export type ${name} = ${unionString};`;
}

/** Generate enum as a TypeScript enum */
function generateEnumAsEnum(
  name: string,
  enumValues: string[],
  enumNames?: string[],
): string {
  const entries = enumValues.map((value, index) => {
    const key = enumNames?.[index] ?? JSON.stringify(value);
    return `${key}=${JSON.stringify(value)}`;
  });

  return `export enum ${name} {${entries.join(",")}}`;
}

export { generateTypes };

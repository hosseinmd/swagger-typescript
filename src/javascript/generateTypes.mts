import { getRefName, getSchemaName, getTsType } from "./utils.mjs";
import type { Schema, Config, TypeAST } from "../types.mjs";
import { AUTOGENERATED_COMMENT } from "./strings.mjs";
import { getJsdoc } from "../utilities/jsdoc.mjs";
import { isAscending } from "../utils.mjs";

/**
 * Generates TypeScript type definitions from an array of type ASTs
 *
 * @param types - Array of type AST objects to generate types from
 * @param config - Configuration object for generation options
 * @returns Generated TypeScript type definitions as a string
 * @throws Error when type generation fails
 */
function generateTypes(types: TypeAST[], config: Config): string {
  if (!types || !Array.isArray(types)) {
    throw new Error("Invalid types array provided to generateTypes");
  }

  if (!config) {
    throw new Error("Configuration object is required for generateTypes");
  }

  let code = AUTOGENERATED_COMMENT;

  const sortedTypes = types.sort(({ name }, { name: otherName }) =>
    isAscending(name, otherName),
  );

  for (const { name: typeName, schema, description } of sortedTypes) {
    try {
      const name = getSchemaName(typeName);
      const typeJsdoc = getJsdoc({
        ...schema,
        description: description || schema?.description,
        deprecated: schema?.deprecated
          ? schema?.["x-deprecatedMessage"] || String(schema?.deprecated)
          : undefined,
      });

      const typeDefinition = getTypeDefinition(name, schema, config);

      code += `
        ${typeJsdoc}
        ${typeDefinition}
        `;
    } catch (error) {
      console.error(`Failed to generate type for "${typeName}":`, error);
      // Continue processing other types instead of failing completely
    }
  }

  return code;
}

// Constants for schema types
const SCHEMA_TYPES = {
  ARRAY: "array",
  OBJECT: "object",
  STRING: "string",
} as const;

const FALLBACK_TYPE = "unknown";
const DEFAULT_ANY_TYPE = "any";

/**
 * Generates a TypeScript type definition for a given schema
 *
 * @param name - The name of the type to generate
 * @param schema - The schema object defining the type structure
 * @param config - Configuration object for generation options
 * @returns TypeScript type definition as a string
 */
function getTypeDefinition(
  name: string,
  schema: Schema = {},
  config: Config,
): string {
  const {
    type,
    enum: Enum,
    "x-enumNames": enumNames,
    allOf,
    oneOf,
    items,
    $ref,
    additionalProperties,
    properties,
  } = schema;

  if (Enum) {
    return generateEnumDefinition(name, Enum, enumNames, config);
  }

  if (allOf || oneOf) {
    return `export type ${name} = ${getTsType(schema, config)};`;
  }

  if (type === SCHEMA_TYPES.ARRAY && items) {
    return `export type ${name} = (${getTsType(items, config)})[];`;
  }

  if ($ref) {
    return `export type ${name} = ${getRefName($ref)};`;
  }

  if (type === SCHEMA_TYPES.OBJECT) {
    const typeObject = getTsType(schema, config);

    if ((additionalProperties || properties) && !oneOf) {
      return `export interface ${name} ${typeObject}`;
    }

    return `export type ${name} = ${typeObject};`;
  }

  if (type === SCHEMA_TYPES.STRING) {
    return `export type ${name} = ${type};`;
  }

  return `export type ${name} = ${DEFAULT_ANY_TYPE};`;
}

/**
 * Generates enum definition based on configuration
 *
 * @param name - The enum name
 * @param enumValues - Array of enum values
 * @param enumNames - Optional array of enum names
 * @param config - Configuration object
 * @returns TypeScript enum or type union definition
 */
function generateEnumDefinition(
  name: string,
  enumValues: string[],
  enumNames: string[] | undefined,
  config: Config,
): string {
  if (config.generateEnumAsType) {
    const enumString = enumValues.length
      ? enumValues.map((e) => JSON.stringify(e)).join(" | ")
      : FALLBACK_TYPE;

    return `export type ${name} = ${enumString};`;
  }

  const enumEntries = enumValues.map((e, index) => {
    const enumKey = enumNames ? enumNames[index] : JSON.stringify(e);
    return `${enumKey}=${JSON.stringify(e)}`;
  });

  return `export enum ${name} {${enumEntries.join(",")}}`;
}

export { generateTypes };
